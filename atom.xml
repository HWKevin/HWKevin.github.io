<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HWKevin&#39;s Blog</title>
  
  <subtitle>Explore the world together</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-26T06:26:10.151Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>linzhenxian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【回顾数据库知识点】</title>
    <link href="http://yoursite.com/2018/03/21/%E3%80%90%E5%9B%9E%E9%A1%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E3%80%91/"/>
    <id>http://yoursite.com/2018/03/21/【回顾数据库知识点】/</id>
    <published>2018-03-21T08:52:17.000Z</published>
    <updated>2018-03-26T06:26:10.151Z</updated>
    
    <content type="html"><![CDATA[<p>关系模型数据库<br>基本的关系操作<br>常用的关系操作包括查询、插入、删除、修改<br>查询操作<br>选择(select) 投影(project) 连接(join) 除(divide) 并(union) 差(except) 交(intersection)<br>其中选择、投影、并、差、笛卡尔积等5种基本操作<br>其他操作可以用基本操作来定义和导出</p><p>完成核心功能只用9个动词<br>SQL功能 动词<br>数据查询 select<br>数据定义 create、drop、alter<br>数据操纵 insert update delete<br>数据控制 grant revoke<br><a id="more"></a><br>数据定义<br>创建模式  create schema 删除模式 drop schema<br>创建表  create table  删除表drop table 修改 alter table<br>视图  create view  删除视图 drop view<br>索引 create index 删除索引 drop index</p><p>模式的定义<br>在create schema中可以create table 操作index索引 操作视图view<br>create schema &lt;模式名&gt; authorization &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]<br>如果没有指定&lt;模式名&gt;，那么&lt;模式名&gt;隐含为&lt;用户名&gt;</p><p>删除模式<br>drop schema &lt;模式名&gt;&lt;cascade|restrict&gt;<br>删除模式的同事把该模式中的所有数据库对象全部删除<br>cascade(级联):删除模式的同时把该模式中的所有的数据库对象全部删除<br>restrict(限制):如果该模式中定义了下属的数据库对象(如表、视图)，则拒绝删除语句的执行<br>当该模式中没有任何下属的对象才能执行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关系模型数据库&lt;br&gt;基本的关系操作&lt;br&gt;常用的关系操作包括查询、插入、删除、修改&lt;br&gt;查询操作&lt;br&gt;选择(select) 投影(project) 连接(join) 除(divide) 并(union) 差(except) 交(intersection)&lt;br&gt;其中选择、投影、并、差、笛卡尔积等5种基本操作&lt;br&gt;其他操作可以用基本操作来定义和导出&lt;/p&gt;
&lt;p&gt;完成核心功能只用9个动词&lt;br&gt;SQL功能 动词&lt;br&gt;数据查询 select&lt;br&gt;数据定义 create、drop、alter&lt;br&gt;数据操纵 insert update delete&lt;br&gt;数据控制 grant revoke&lt;br&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>H5css规范</title>
    <link href="http://yoursite.com/2018/03/20/H5css%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/03/20/H5css规范/</id>
    <published>2018-03-20T05:05:31.000Z</published>
    <updated>2018-03-26T07:05:18.861Z</updated>
    
    <content type="html"><![CDATA[<p>语法：用两个空格来代替制表符(tab)保证唯一能在所在环境下获得一致展现的方法<br>嵌套元素应当缩进一次(两个空格)<br>对于属性的定义，确保全部使用双引号，绝对不适用双引号<br>不再在自闭和(self-closing)元素的尾部添加斜线<br>不要省略可选的结束标签(closing tag)<code>&lt;/li&gt;&lt;/body&gt;</code></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTML5 DOCTYPE</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>语言属性：<br>HTML5规范：HTML根元素指定lang属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>IE兼容模式<br>IE支持通过特定的<meta>标签来确定绘制当前页面所应该采用的IE版本<br><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; Content=&quot;IE=edge&quot;&gt;</code><br>字符编码<br><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></p><p>引入CSS和Script<br><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;code-guide.css&quot;&gt;</code><br><code>&lt;script src&gt;</code></p><p>实用为王<br>尽量遵循HTML标准和语义，但不要牺牲实用性，任何时候都要尽量使用最少的标签并保持最小的复杂度</p><p>属性排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class  id,name  date-*  src,for,type,href,value  title,alt  role,aria-* </span><br><span class="line">class用于标识高度可复用组件，因此应该排在首位，id用于标识具体组件，应当谨慎使用，因此排在第二位</span><br></pre></td></tr></table></figure></p><p>布尔型属性<br>可以在声明时不赋值，XHTML规范要求为其赋值，但是HTML5规范不需要<br>元素的布尔型属性如果有值，就是true，没有值就是false<br>如果一定要为其赋值，简单来说就是不用赋值</p><p>减少标签的数量<br>通过JavaScript生成的标签让内容变得不易查找、编辑，并且降低性能，能避免时尽量避免</p><p>CSS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// Bad css</span><br><span class="line">.selector, .selector-secondary, .selector[type=text]&#123;</span><br><span class="line">padding:15px;</span><br><span class="line">margin:0px 0px 15px;</span><br><span class="line">background-color:rgba(0,0,0,0,0.5);</span><br><span class="line">box-shadow:0px 1px 2px #ccc,inset 0 1px 0 #FFFFFF;</span><br><span class="line">&#125;</span><br><span class="line">// Good CSS</span><br><span class="line">.selector,</span><br><span class="line">.select-secondary,</span><br><span class="line">.selector[type=&quot;test&quot;]&#123;</span><br><span class="line">padding:15px;</span><br><span class="line">marign-bottom:15px;</span><br><span class="line">background-color:rgba(0,0,0,0,0.5);</span><br><span class="line">box-shadow:0px 1px 2px #ccc,inset 0 1px 0 #FFFFFF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.declaration-order &#123;</span><br><span class="line">  /* Positioning */</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  z-index: 100;</span><br><span class="line"></span><br><span class="line">  /* Box-model */</span><br><span class="line">  display: block;</span><br><span class="line">  float: right;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line"></span><br><span class="line">  /* Typography */</span><br><span class="line">  font: normal 13px &quot;Helvetica Neue&quot;, sans-serif;</span><br><span class="line">  line-height: 1.5;</span><br><span class="line">  color: #333;</span><br><span class="line">  text-align: center;</span><br><span class="line"></span><br><span class="line">  /* Visual */</span><br><span class="line">  background-color: #f5f5f5;</span><br><span class="line">  border: 1px solid #e5e5e5;</span><br><span class="line">  border-radius: 3px;</span><br><span class="line"></span><br><span class="line">  /* Misc */</span><br><span class="line">  opacity: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不要使用@import<br>与<code>&lt;link&gt;</code>标签相比，@import指令要慢很多，不光 增加了额外的请求次数，还会导致不可预料的问题。替代方法<br>使用多个<code>&lt;link&gt;</code>元素<br>通过Sass或Less类似的Css预处理器将多个CSS文件编译为一个文件<br>通过Rails、Jekyll或其他系统中提供过CSS文件合并功能</p><p>媒体查询(Media query)的位置<br>将媒体查询放在尽可能相关规则的附近，不要将他们打包放在一个单一样式文件中或者放在文档底部，如果你把他们分开了，将来只会忘记<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.element &#123; ... &#125;</span><br><span class="line">.element-avatar &#123; ... &#125;</span><br><span class="line">.element-selected &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">@media (min-width: 480px) &#123;</span><br><span class="line">  .element &#123; ...&#125;</span><br><span class="line">  .element-avatar &#123; ... &#125;</span><br><span class="line">  .element-selected &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>带前缀的属性<br>当使用特定厂商的带有前缀的属性时，通过缩进的方式，让每个属性的值在垂直方向对齐，这样便于多行编辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Prefixed properties */</span><br><span class="line">.selector &#123;</span><br><span class="line">  -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15);</span><br><span class="line">          box-shadow: 0 1px 2px rgba(0,0,0,.15);</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>单行规则声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Single declarations on one line */</span><br><span class="line">.span1 &#123; width: 60px; &#125;</span><br><span class="line">.span2 &#123; width: 140px; &#125;</span><br><span class="line">.span3 &#123; width: 220px; &#125;</span><br><span class="line"></span><br><span class="line">/* Multiple declarations, one per line */</span><br><span class="line">.sprite &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 16px;</span><br><span class="line">  height: 15px;</span><br><span class="line">  background-image: url(../img/sprite.png);</span><br><span class="line">&#125;</span><br><span class="line">.icon           &#123; background-position: 0 0; &#125;</span><br><span class="line">.icon-home      &#123; background-position: 0 -20px; &#125;</span><br><span class="line">.icon-account   &#123; background-position: 0 -40px; &#125;</span><br></pre></td></tr></table></figure></p><p>简写形式的属性声明<br>在需要显示地设置所有制的情况下，应当尽量限制使用简写形式的属性声明<br>常见滥用简写属性声明的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">padding</span><br><span class="line">margin</span><br><span class="line">font</span><br><span class="line">background </span><br><span class="line">border</span><br><span class="line">border-radius</span><br><span class="line">/* Bad example */</span><br><span class="line">.element &#123;</span><br><span class="line">  margin: 0 0 10px;</span><br><span class="line">  background: red;</span><br><span class="line">  background: url(&quot;image.jpg&quot;);</span><br><span class="line">  border-radius: 3px 3px 0 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Good example */</span><br><span class="line">.element &#123;</span><br><span class="line">  margin-bottom: 10px;</span><br><span class="line">  background-color: red;</span><br><span class="line">  background-image: url(&quot;image.jpg&quot;);</span><br><span class="line">  border-top-left-radius: 3px;</span><br><span class="line">  border-top-right-radius: 3px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Less和Sass中的嵌套<br>避免不必要的嵌套只有在必须将样式限制在父元素内也就是后代选择器，冰鞋存在多个需要嵌套元素时才使用嵌套<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Without nesting</span><br><span class="line">.table &gt; thead &gt; tr &gt; th &#123; … &#125;</span><br><span class="line">.table &gt; thead &gt; tr &gt; td &#123; … &#125;</span><br><span class="line"></span><br><span class="line">// With nesting</span><br><span class="line">.table &gt; thead &gt; tr &#123;</span><br><span class="line">  &gt; th &#123; … &#125;</span><br><span class="line">  &gt; td &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Less和Sass中的操作符<br>为了挺高可读性，在圆括号中的数学计算表达式的数值、变量和操作符之间均添加一个空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Bad example</span><br><span class="line">.element &#123;</span><br><span class="line">  margin: 10px 0 @variable*2 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Good example</span><br><span class="line">.element &#123;</span><br><span class="line">  margin: 10px 0 (@variable * 2) 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注释<br>代码是由人编写并且维护的，好的代码注释能够传达上下文关系和代码目的，不要简单地重申组件或class名称<br>对于较长的注释，务必书写完整的句子；对于一般性朱姐，可以书写简洁的短语<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Bad example */</span><br><span class="line">/* Modal header */</span><br><span class="line">.modal-header &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Good example */</span><br><span class="line">/* Wrapping element for .modal-title and .modal-close */</span><br><span class="line">.modal-header &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>class命名<br>class名称中只能出现小写字符和破折号{不是下划线，也不是驼峰命名法}{例如.btn 和.btn-danger<br>避免过度任意的简写，.btn代表button，但是.s不能表达任何意思<br>class名称应尽可能短，意义明确<br>使用有意义的名称，使用有组织的或目的明确的名称，并且不要使用表现形式presentational的名称<br>基于最近的父class或基本class作为新class的前缀<br>使用<code>.js-*</code>class来标识行为，并且不要将这些class包含到CSS文件中</p><p>选择器<br>对于通用元素使用class，这样便于渲染的优化<br>对于经常出现的组件，避免使用属性选择器，浏览器的性能会受到这些因素的影响<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Bad example */</span><br><span class="line">span &#123; ... &#125;</span><br><span class="line">.page-container #stream .stream-item .tweet .tweet-header .username &#123; ... &#125;</span><br><span class="line">.avatar &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">/* Good example */</span><br><span class="line">.avatar &#123; ... &#125;</span><br><span class="line">.tweet-header .username &#123; ... &#125;</span><br><span class="line">.tweet .avatar &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;语法：用两个空格来代替制表符(tab)保证唯一能在所在环境下获得一致展现的方法&lt;br&gt;嵌套元素应当缩进一次(两个空格)&lt;br&gt;对于属性的定义，确保全部使用双引号，绝对不适用双引号&lt;br&gt;不再在自闭和(self-closing)元素的尾部添加斜线&lt;br&gt;不要省略可选的结束标签(closing tag)&lt;code&gt;&amp;lt;/li&amp;gt;&amp;lt;/body&amp;gt;&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="html/css 规范" scheme="http://yoursite.com/tags/html-css-%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>【javaScript】学习笔记</title>
    <link href="http://yoursite.com/2018/03/14/%E3%80%90javaScript%E3%80%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/03/14/【javaScript】学习笔记/</id>
    <published>2018-03-14T11:46:43.000Z</published>
    <updated>2018-04-09T01:29:55.252Z</updated>
    
    <content type="html"><![CDATA[<p>javascript有三部分组成<br>核心ECMAscript<br>文档对象模型DOM (Document Object Model) 提供访问和操作网页内容的方法和借口<br>浏览器对象模型BOM (Browser Object Model) 提供与浏览器交互的方法与借口</p><p>组成部分：语法、类型、语句、关键字、保留字、操作符、对象<br><a id="more"></a></p><p>在<code>&lt;script&gt;</code>内容内不能出现<code>&lt;/script&gt;</code><br>即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function a&#123;</span><br><span class="line">alert(&quot;&lt;/script&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>而应该是加入反斜杠<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function a&#123;</span><br><span class="line">alert(&quot;&lt;\/script&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>因为按照解析嵌入式代码的负责，当浏览器遇到即会认为是结束标签</p><p>为了避免加载javascript而造成延迟期间的浏览器窗口一片空白，现在通常是在<body>标签中，内容的下方放置<code>&lt;script&gt;</code></body></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--内容--&gt;</span><br><span class="line">&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>延迟脚本defer属性，只支持外部属性,把延迟脚本放在页面底部仍是最佳选择</p><script src="1.js" defer="defer"></script><p>异步属性async属性，不按顺序来执行javascript文件，来达到异步执行的作用</p><p><code>&lt;noscript&gt;</code>元素<br>    不支持script的浏览器会显示该属性</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ol><li>区分大小写</li><li>标识符<br> 变量、函数、属性的名字，或者函数的参数。<br>规则：</li></ol><ul><li>第一个字符必须是一个字母，下划线(_)或者美元符号($)</li><li>其他字符可以使字母、下划线、美元符号、数字</li></ul><ol><li><p>注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//单行注释</span><br><span class="line">/*</span><br><span class="line"> *多行注释</span><br><span class="line"> *</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li><li><p>严格模式<br>语法：<code>*use strict*</code></p></li><li><p>语句<br>每行结尾必须要带分号，最好还是在{}内进行编写(代码块)</p></li><li><p>关键字和保留字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ECMAscript的全部关键字</span><br><span class="line">break do instanceof typeof case else new var catch finally return void continue for switch while debugger function this with default if throw delete in try</span><br><span class="line"></span><br><span class="line">保留字</span><br><span class="line">abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public</span><br><span class="line"></span><br><span class="line">第5版在非严格模式下运行时的保留字缩减为</span><br><span class="line">class enum extends super conset export import </span><br><span class="line">在严格模式下，第5班对以下保留字施加限制</span><br><span class="line">implements package public interface private static let protected yield</span><br></pre></td></tr></table></figure></li><li><p>变量<br>ECMAScript的变量是松散类型，用来保存任何类型的数据，每个变量仅仅是一个用于保存值的占位符。定义变量的时使用var操作符，勾结一个标识符。<br>var message 定义了一个名为message的变量。可以用保存任何值，为为进过初始化的</p></li></ol><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Number类型<br>    浮点数值</p><pre><code>    对于极大或极小的数值，可以用e表示法    var floatNum= 3.1415e7;//等于3.1415乘以10    实际含义就是3.1415乘以10的7次方。    负电数值的最高精度是17位小数，但在进行算术计算时的精确度远远不如整数。例如0.1加0.2的结果不是0.3 而是0.30000000000000004.这个小小的舍入误差会导致无法测试特定的浮点数值。    因此，永远不要测试某个特定的浮点数值。数值范围    isFinite()确定在有效区间内    isFinite(result);NaN(Not A Number)isNaN()用来检测变量是否是NaNalert(isNaN(NaN))//truealert(isNaN(&quot;10&quot;))//falsealert(isNaN(&quot;blue&quot;))//truealert(isNaN(true))//false boolean型可以转换成1alert(isNaN(10))//false数值转换 Number() parseInt() parseFloat()Number()转换规则boolean -&gt; 0 1数字值  -&gt; 数字值null -&gt; 0undefined -&gt; 返回NaN字符串    只包含数字。只会转换成十进制。前面有0将会忽略        包含有效的浮点格式。转换成对应的浮点数    包含有效的十六进制格式(0x)，则将其转换成相同大小的十进制整数值    字符串为空，转换成0    除以上格式，转换成NaN如果为对象，则代用对象的valueOf()方法，然后依照前面的规则转换返回的值，如果转换的结果为NaN，则调用对象的方法toString()方法，然后再次依照前面的规则转换返回的字符串值。    例子：        var num1 = Number(&quot;Hello World&quot;)    //NaN        var num2 = Number(&quot;10&quot;)                //10        var num3 = Number(&quot;&quot;)                 //0        var num4 = Number(&quot;true&quot;)            //1    由于Number()函数在转换字符串比较复杂,处理整数时通常采用parseInt()函数。会忽略字符串前面的空格，直至找到第一个非空格字符。即如果第一个字符不为数字，即类型会转换为NaN;可以识别三种进制格式。但要在后面添加一个参数。即 parseInt(&quot;071&quot;,8)八进制数——&gt;十进制15        var parseInt1 = parseInt(&quot;123abc&quot;);// 123        var parseInt2 =    parseInt(&quot;&quot;); //NaN        var parseInt3= parseInt(&quot;071&quot;,8); //八进制 十进制数为15        var parseInt4 = parseInt(&quot;A&quot;,16); //十六进制 十进制数为10</code></pre><p>字符串类型 string<br>可用””或者’’两种语法形式<br>var testString = “test”;<br>var testString = ‘test’;</p><ol><li>字符串字面量<br>String包含一些特殊的字符字面量，转义字符。用于表示非打印字符，或者具有其他用途的字符。这些字符字面量如下表<br>\n换行 \t制表 \b空格 \r回车 \f \’ * \” \xnn \unnn </li><li><p>字符串的特点<br> 创建后不能更改，其值不能盖改变，要改变某个变量保存的字符串，只能销毁原本的字符串，然后在用另一个包含新值的字符串填充该变量<br> var lang= “hello”;<br> var lang=lang+”world”;//lang为helloworld</p></li><li><p>转换为字符串<br> 除了undefined、null值没有toString方法，最后得出的toString就是字符串。<br> String所有类型都会有返回值。<br> var num1=”10”;<br> var num2;<br> var num3=true;<br> var num4=null;<br> var num5 = “one”;<br> alert(String(num1));//“10”<br> alert(String(num2));//“undefined”<br> alert(String(num3));//“true”<br> alert(String(num4));//“null”<br> alert(String(num5));//“one”</p></li></ol><p>Object类型<br>    ECMAScript中的对象就是一组数据与功能的集合。对象可以通过执行new操作符后跟要创建的的对象类型的名称来创建，而创建Object类型的实例并未其添加属性和方法，就可以创建自定义对象。<br>    创建Object()类型的实例可以创建自定义对象，如下：<br>        var object = new Object();<br>    Constructor(建造者)    保存用于创建当前对象的函数，上面的构造函数就是Object();<br>    hasOwnProperty(propertyName)用于检查当前对象实例属性是否存在。<br>    isPrototypeOf(object)传入对象是否是另一个对象的原型<br>    propertyIsEnumberable(propertyName)当前对象属性是否能使用for-in语句枚举<br>    toLocaleString()返回对象的字符串表示，字符串根据地区对应<br>    toString()返回对象的字符串表示<br>    valueOf()返回布尔值、number、string类型表示</p><pre><code>关于原型链的一些理解：原型链的本质是__proto__;每个属性都会有__proto__属性。function a(c){    this.b=c;    this.d=function(){        alert(this.b);    }}a.prototype.test=function(){    alert(this.b);}obj.prototype = function(){    obj.prototype=new a(&quot;test&quot;);}var k= new obj(&quot;test&quot;);k.test();//</code></pre><p>undefined类型<br>    undefined只有一个值，在使用var声明变量但未对其加以初始化，这个变量的值就是undefined。 </p><p>null类型<br>    null类型只有一个值。从逻辑角度看，null表示一个空对象指针。使用typeod操作符检测null值会返回”object”。在确定变量是保存对象。最好将该变量初始化为null而不是其他值，这样一来，只要直接检查null值就可以知道相对应的变量是否已经保存了一个对象的引用。<br>    如：<br>    if(car != null){<br>        // 对car对象执行某些操作<br>    }<br>    实际上，undefined值是派生自null值的。因此alert(undefined==null) //true<br>    尽管有这种关系，用途不同。只需要在意保存对象的变量还没有真正保存对象，就应该明确的让该变量保存null值，这样做不仅可以体现null作为空对象指针的管理，而且有主与进一步区分null和undefined</p><p>Boolean类型<br>只有两个字面值：true 和false 这两个值与数字值不是一回事，因此true不一定等于1，而false不一定等于0；<br>布尔类型转换 Boolean()方法<br>各种Boolean()类型转换按照以下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据类型转换为true的值转换为false的值</span><br><span class="line">Boolean     truefalse</span><br><span class="line">string 非空字符串空字符串</span><br><span class="line">number 非0数字0和NaN</span><br><span class="line">undefined 转换成false</span><br><span class="line">null 转换成false</span><br><span class="line">object 任何对象null</span><br></pre></td></tr></table></figure></p><ol><li><p>保存类型<br>6种类型 undefined null number string Boolean object到最后就是保存为上面的其中一种<br>object本质上是由一组无序的名值对组成。<br>ECAMScript不支持任何创建自定义类型的机制，所有制最终都是上面的6种之一</p></li><li><p>tyepof操作符 可返回下列某个字符串</p></li><li><p>操作符<br>一元操作符 ++ –<br>位操作符<br>第32位为记录整数的正负，0为整数 1为负数<br>整数直接二进制保存<br>负数 绝对值二进制 取补码(0变成1，1变成0)最后一位加上1 就成了负数<br>ECMAScript中已经对负数二进制以更合乎逻辑的形式展示了出来。</p></li></ol><ul><li>按位非<br>(~)波浪线表示，按位非就是取数值的反码。<br>var num1=15;        //二进制0000 0000 0000 0000 0000 0000 0000 1111<br>var num2= ~num1;    //二进制1111 1111 1111 1111 1111 1111 1111 0000<br>alert(num2);         //输出为-16</li></ul><p>本质：操作数的负值减1</p><ul><li><p>按位与<br>相同为1时合并为1，不同时为1即为0<br>(&amp;)符号表示<br>var result=15 &amp; 3;<br>alert(result);//3</p></li><li><p>按位或<br>只要有一个1时就为1<br>(|)符号表示<br>var result=15 | 3;<br>alert(result);  //15</p></li><li><p>按位异或<br>相同时为0 单独有个1就为1<br>按位异或 操作符由一个插入符号(^)<br>var result = 15 ^ 3;<br>alert(result);  //12</p></li><li><p>左移<br>左移操作符由两个小于号(&lt;&lt;)</p></li><li><p>右移<br>右移操作符由两个大于号(&gt;&gt;)</p></li></ul><h2 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h2><ol><li><p>逻辑非<br>逻辑非操作符由叹号(!)<br> 例子:<br> alert(!true);    // false<br> alert(!0);            //true<br> alert(!NaN);     //true<br> alert(!””);        //true<br> alert(!”test”);    //false<br> alert(!null);    //true<br> alert(!1235);    //false<br>逻辑非操作符可以将一个值转换成布尔型。类似于Boolean()方法<br>可以用两个逻辑非操作符将值转换成对应的布尔型 var test=!!123;//test=true;</p></li><li><p>逻辑与<br>逻辑与操作符由两个(&amp;&amp;)表示，有两个操作数。<br>var result = true &amp;&amp; false;<br>逻辑：两个操作数都要是true，得出的逻辑与就是true。否则就是false<br>逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔型，在有一个操作数不是布尔型的情况下，按下面的规则来进行逻辑与操作</p></li></ol><ul><li>第一个为对象，输出后面的操作数</li><li>第二个为对象，只有在前面为true，后面的才能输出</li><li>两个都为对象，则输出后面的</li><li>有一个操作数为null，输出null</li><li>undefined同上</li><li>NaN同上<br>逻辑非为短路操作，如果前面能决定结果，那么就不会对第二个操作数求职。对于逻辑与操作而言，</li></ul><ol><li>逻辑或<br>(||)<br>var result=true || false //true<br>非布尔型规则<br> 第一个为true时，返回true<br> 第一个操作数为对象时，返回第一个对象。<br> 第一个操作数为false时，返回第二个操作数。</li></ol><h2 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h2><p>乘法 *<br>除法 /<br>求模 &amp;</p><h2 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h2><p>加法操作符+<br>number类型直接相加<br>其他类型通过Number()转换。字符串相连接在一起</p><h2 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h2><p>&lt;、&gt;、= 要看数据类型来进行判断，如果是nember就直接进行比较，如果不是就通过规则进行比较<br>如果两个操作数都是字符串，那么比较两个字符串对应的字符编码值<br>如果一个操作数是数字，那么另一个转换成数字类型进行比较<br>如果是对象，就使用valueOf()进行转换，再通过上面方法进行比较。</p><h2 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h2><p>==  !=<br>相等与不相等 全等于不全等</p><h3 id="相等与不相等-是转换后进行比较。"><a href="#相等与不相等-是转换后进行比较。" class="headerlink" title="相等与不相等 是转换后进行比较。"></a>相等与不相等 是转换后进行比较。</h3><p>如果有一个操作数是布尔值，则在比较相等性之前现将其转换成数值——false转换为0.而true转换成1<br>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前现将字符串转换成数值。<br>如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法， 用的到的基本类型之按照前面的规则进行比较。<br>一字符 一string 先将string转换成number后进行比较。<br>一对象一不是，调用对象的valueOf()函数转换然后上面方法比较，<br>null与undefined是相同的<br>在比较相等性之前，不能将null与undefined转换成其他任何职<br>如果有一个数是NaN。则相等操作符返回false，不相等操作符返回true。<br>两个都是对象，如果两个对象指向一个，那么相等操作符返回true，否则。返回false</p><h3 id="全等和不全等是不转换就进行比较"><a href="#全等和不全等是不转换就进行比较" class="headerlink" title="全等和不全等是不转换就进行比较"></a>全等和不全等是不转换就进行比较</h3><p>=== !==</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="do-while-while-if-for循环语句"><a href="#do-while-while-if-for循环语句" class="headerlink" title="do-while while if for循环语句"></a>do-while while if for循环语句</h3><p>for-in语句可以枚举对象中所有属性<br>null和undefined不能执行该循环体，所以需使用propertyIsEnumberable(propertyName)来检测该对象属性能否被枚举</p><h3 id="for-in语法"><a href="#for-in语法" class="headerlink" title="for-in语法"></a>for-in语法</h3><p>for(property in expression)statement<br>实例<br>for(var propName in window){<br>    document.write(propName);<br>}<br>这个例子，使用for-in循环将window对象中所有的属性都输出出来<br>但是如果要迭代对象的数据类型是null、undefined for-in语句会停止执行，为保持最大限度的兼容性，确定检测对象的值不是null或undefined</p><h3 id="label语句"><a href="#label语句" class="headerlink" title="label语句"></a>label语句</h3><p>使用lable语句可以在代码中添加标签，以便后面使用。语法<br>label:statement<br>实例<br>var count=19;<br>state:for(var i=0;i&lt;count;i++){<br>    alert(i);<br>}<br>这个例子中定义的start标签可以在将来由break或continue语句引用。加标签的语句一般都要与for语句一起使用</p><h3 id="break与continue语句"><a href="#break与continue语句" class="headerlink" title="break与continue语句"></a>break与continue语句</h3><p>用于精确控制循环代码的执行。break会直接退出循环，强制执行后面循环语句<br>continue用于立即退出循环，进行新的一轮循环</p><h3 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h3><p>with语句的作用是将代码的作用域设置到一个特定的对象中。<br>语法<br>with(expression) statment;<br>定义with语句的目的是为了简化多次编写同一个对象的工作。<br>实例<br>var gs=location.serach.substring(1);<br>var hostName=location.hostname;<br>var url=location.href;</p><p>上面的几行代码都包含了location对象，如果使用with语句，可以吧上面的代码改写成如下所示：<br>with(location){<br>    var gs=search.substring(1);<br>    var hostName=hostname;<br>    var url=location.href;<br>}<br>使用with关联location，意味着代码块内部，每个变量都会被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location对象中是否有同名的属性，将该属性作为变量的值。<br>严格模式下将会认为语法错误。with不能用在严格模式下。</p><p>switch语句<br>与其他语言类似，但有一点：可以使用出number以外的类型 string、boolean<br>switch (i){<br>    case 30:<br>        alert(“30”);<br>        break;<br>    case 40:<br>        alert(“40”);<br>        break;<br>}<br>switch(true){<br>    case num&lt;0:<br>        alert(“小于0”);<br>        break;<br>    case num&gt;0 &amp;&amp; num&lt;20:<br>        alert(“大于0小于20”);<br>        break;<br>    case num&gt;=20 &amp;&amp; num&lt;=50:<br>        alert(“大于20小于50”);<br>        break;<br>    default:<br>        alert(“大于50”);<br>}</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>函数对于任何语言来说都是一个核心的概念，通过函数可以封装任意多条语句，而且可以在任何地方，任何时候调用执行。ECMAScript中的函数使用function关键字来声明，后更一组参数以及函数体。函数的基本语法如下所示：function functionName(arg0,arg1,...,argN){    statements}以下是一个函数实例function sayHi(name,message){    alert(&quot;Hello&quot;+name+&quot;,&quot;+message);}调用该函数sayHi(&quot;Kevin&quot;+how art you today);通过ruturn返回值。位于return后面的值永远不会执行。可以直接return直接停止返回undefined 推荐做法是让函数始终返回一个值，要么永远都不要返回值。否则，如果函数有时候返回，有时候不返回，会给吊事代码带来不便严格模式下对函数有一些限制：不能把函数命名为eval或arguments;不能把参数命名为eval或arguments;不能出现两个命名参数同名的情况;重点：js函数中不介意传进多少参数原因：ECMAScript中的参数是在内部用一个数组来表示的，函数接受的的始终都是这个菽粟，而不关心数组中包含哪些参数(如果有参数的话)。如果这个数组红不包含任何元素，无所谓;如果半酣多个元素，也没问题。实际上，在函数体可以通过arguments对象来访问这个参数数组，从而获取床底给函数的每一个参数，其实，arguments对象知识与数组类似(它并不是Array的实例)，因为可以使用方括号语法访问它的每一个元素[](即第一个元素是arguments[0]第二个元素是arguments[1])使用length属性来确定传递进来多少个参数。</code></pre><h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>正因为上面所述的原因，所以ECMAScript函数不能像传统意义上的重载。就是不能像如Java那样可以为一个函数定义两个定义，只要两个定义的签名(接受的参数的类型和数量)不同即可。ECMAScript没有签名，因为其参数是由包含零或者多个值的数组来表示的，而没有函数签名，真正的重载是不能做到的。<br>如果ECMAScript中定义了两个名字相同的函数，则名字只属于后定义的函数。<br>实例：<br>function addNumber(num){<br>    return num+100;<br>}<br>function addNumber(num){<br>    return num+200;<br>}<br>alert(addNumber(100)); //300<br>后定义的函数覆盖了先定义的函数，因此当在最后一刚代码中调用这个函数时，返回的结果就是300</p><p>简要总结ECMAScript基本的要素：</p><ul><li>ECMAScript中的基本数据undefined、null、boolean、string、number、object</li><li>没有为浮点数值定义不同的数据类型，Number类型可用于表示所有值</li><li>有一种复杂的数据类型，object类型，该类型是这门语言中所有对象的基础类型</li><li>严格模式为这门语言中容易出错的地方施加了限制</li><li>ECMAScript从其他语言中借鉴了很多流控制语句、例如 if 、for、switch、</li><li>无须指定函数的返回值，因为任何ECMAScript函数都可以在任何时候返回任何值</li><li>位指定返回值的函数返回的是一个特殊的undefined值</li><li>ECMAScript中没有函数签名的概念，因为其函数参数是一一个包含零或多个值的数组的性质传递的。</li><li>可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数</li><li>由于不存在函数签名的特性，ECMAScript函数并不能重载。</li></ul><h1 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h1><p>基本类型和引用类型<br>基本类型undefined、null、string、number、boolean<br>引用类型object<br>基本类型复制对象是直接复制副本，两个是完全独立的<br>引用类型是复制一个指针，而这个指针指向存储在堆中的一个对象，复制操作结束后，两个变量实际上将一用同一个对象。因此，改变其中一个变量，就会影响另一个变量<br>var obj1=new Object();<br>var obj2=obj1;<br>obj.name=”ke”;<br>alert(obj1.name); //ke</p><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>ECMAScript中所有函数的参数都是按值传递的。函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递。则不同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑。因为访问变量有按值和按引用两种方式，而参数只能按值传递。<br>向参数传递基本类型的值时，被传递的值会被复制给一个局部变量(即命名参数，或者用ECMAScript的概念来说，就是arguments对象中的一个元素。) 在想参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量。因此这个局部变量的变化会反映在函数的外部。<br>function addTen(num){<br>    num+=10;<br>    return num;<br>}</p><p>function addTen(obj){<br>    obj.name=”kevin”;</p><p>}<br>var kp=new Object();<br>addTen(kp);<br>alert(kp.name);        //kevin<br>以上代码上创建一个对象，并将其保存在变化person中。然后，这个对象被传递到setName()函数中之后被复制到obj，在这个函数内部，obj和person引用的是同一个对象，换句话说，即使这个对象是按值传递的，obj也会按引用来访问同一个对象，于是，当在函数内部为obj添加name属性后，函数外部的person也将有所反应。因为person指向的对象在堆内存中只有一个，而且是全局对象，有很多开发人员错误的认为：在局部作用域中修改的对象会在全局作用域中反应出来，就说明参数是按引用传递的。为了证明对象是按值传递的<br>function setName(){<br>    obj.name=”kevin”;<br>    obj=new Object();<br>    obj.name=”Greg”;<br>}</p><p>var person = new Object();<br>setName(person);<br>alert(person.name);    //“kevin”<br>在把person传递给setName()后，其name属性被设置成”kevin”。然后，又将一个新对象赋值给变量obj，同时将其值name属性设置为”Greg”，如果person是按引用传递的，那么person就会自动被修改为指向其name属性值为”Greg”的新对象。但是，当接下来再访问person.name时，显示的值仍然是”kevin”。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当函数内部重写obj时。这个变量应用的就是一个局部对象那个了，而这个局部对象会在函数执行完毕后立即被销毁。</p><h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><p>想知道是什么类型的对象。为此，ECMAScript提供了instanceof操作符。<br>语法：<br>result= variable instanceof constructor<br>alert(person instanceof Object);    //    变量person是Object吗？<br>alert(colors instanceof Array));    //    变量color是Array吗？<br>alert(pattern instanceof RegExp);    //     变量pattern是RegExp吗？</p><p>根据规定，国有引用类型的值都是Object的实例，因此，在检测一个引用类型之和Object构造函数时，instanceof操作符始终会返回true。当然，如果使用instanceof操作符检测基本类型的值，则该操作符始终会返回false。因为基本类型不是对象。</p><h3 id="执行环境与作用域"><a href="#执行环境与作用域" class="headerlink" title="执行环境与作用域"></a>执行环境与作用域</h3><p>执行环境是javaScript最为重要的一个概念，执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象(variabel object)。环境中定义的所有变量和函数都保存在这个变量对象中。(window对象)为全局执行环境。<br>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的换金就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出。<br>带代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途模式保证对执行环境有权访问的所欲变量和函数的有序访问。</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><pre><code>垃圾收集机制的原理：找到不再继续使用的变量，然后释放其占用的内存，为此，垃圾收集器会按照固定的时间间隔(或代码执行中预定的实际时间)，周期性地执行这一操作。</code></pre><p>两个清楚策略：标记清除<br>常用的立即收集方式。当变量进入环境，就将这个变量标记为”进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们，而当变量离开环境时，则将其标记为”离开环境”。<br>可以使用任何方式来标记变量，比如，可以通过翻转，某个特殊的位来记录一个变量何时进入了环境，或者使用一个”进入环境的”变量列表及一个”离开环境的”变量列表来跟踪哪个变量发生了变化，说到底，若何标记标量其实是并不重要，关键在于采取什么策略。<br>垃圾收集器在运行的时候会给存储在内存中的所有变量加上标记(当然，可以使用任何标记方式)。然后，它会去掉环境中的变量以及环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了，最后，垃圾收集器完成内存清除工作，销毁那些带有标记的值并回收它们所占用的内存空间。</p><h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3><p>function createPerson(name){<br>    var localPerson = new Object();<br>    localPerson.name=name;<br>    return localPerson;<br>}<br>var globalPerson=createPerson(“keivn”);<br>//使用后手动将globalPerson的引用解除</p><p>globalPerson=null;<br>这个叫做解除引用，解除一个值的引用并不意味着自动回收该值所占用的内存，真正的作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p><p>小结：<br>JavaScript变量可以用来保存两种类型的值：基本类型和引用类型。基本类型有5种：undefined、null、<br>number、string、boolean。引用类型就只有一种：object类型。有一下特点：</p><ul><li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中</li><li>从一个变量向另一变量复制基本类型的值，会创建这个值的一个副本</li><li>引用类型的值是对象，保存在栈内存中</li><li>包含引用类型值的变量实际上包含的并不是对象本身，而是指向对象的一个指针。</li><li>从一个变量向另一个变量复制引用类型的值， 复制的其实是指针，因此两个变量最终都指向同一个对象</li><li>确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。</li></ul><p>所有变量(包括基本类型和引用类型)都存在一个执行环境(也称为作用域)当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。一下是关于执行环境的加点总结：</p><ul><li>执行环境有全局执行环境(也称全局环境)和函数执行环境之分</li><li>每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链</li><li>函数的局部环境不仅有权访问函数作用域于中的变量，而且有权访问其包括(父)环境，乃至全局环境</li><li>全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据</li><li>变量的执行环境有助于确定应该何时释放内存</li></ul><p>JavaScript是一门具有自动垃圾收集机制的编程语言。<br>总结：</p><ul><li>离开作用域的值被自动标记为可以回收，因此将在啊垃圾收集期间被删除</li><li>“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存</li><li>另一种垃圾收集算法是”引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎幕墙都不再使用这种算法；但在IE访问非原生JavaScript(DOM等元素)时，这种算法仍然可能会导致出现问题</li><li>当代码中存在循环引用现象时，”引用计数”算法就会导致问题</li><li>解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用</li></ul><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>内容：使用对象、创建并操作数组、使用基本的JavaScript类型、使用基本类型的基本包装类型<br>引用类型的值(对象)是引用类型的一个实例，引用类型是一种数据结构，用于将数据和功能组织在一起，它通常被称为类，但这种称呼并不太对。引用类型有时候也被称为对象定义。</p><p>Object类型<br>两种创建方法<br>第一种是使用new操作符后跟Object构造函数。<br>var person= new Object();<br>person.name=”jjk”;<br>person.age=23;<br>另一种是使用对象字面量<br>var person={<br>    name : “jjk”,<br>    age : 21<br>};<br>在对象字面量里，使用冒号后接这个属性的值，使用逗号分隔两个变量。最后一个变量不能使用逗号分隔。<br>在使用对象字面量语法时，属性名也可以使用字符串<br>var person={<br>    “name”:”jjk”;<br>    “age”:”12”;<br>    5:ture;<br>}<br>这个例子会创建一个对象，包含三个属性：name、age、5。这里的数值属性名会自动转换为字符串<br>使用对象可以留空花括号，则可以定义只包含默认属性和方法的对象<br>var person={};<br>person.name=”jjk”;<br>person.age=29;</p><p>一般来说，访问对象属性时使用的都是点表示法，不过js中也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号中<br>persion.name;<br>persion[“name”];</p><p>Array类型：<br>创建数组的基本方式有两种。第一种是使用Array构造函数<br>var colors=new Array();</p><p>var colors=new Array(20);    //创建length值为20的数组<br>var colors=new Array(“blue”,”black”);    //    创建包含2个字符串值的数组<br>可以省略new操作符<br>var colors=Array();</p><p>第二种基本方式是使用数组字面量表示法。数组字面量由一堆包含数组项的方括号表示，多个数组项之间以逗号隔开。<br>var colors=[“red”,”blue”,”green”];<br>var names=[];</p><p>数组的length属性很有特点——它不是只读的，因此，通过设置这个属性，可以从数组额末尾移除项或向数组中添加新项<br>var colors=[“red”,”blue”,”green”];    //    创建一个包含3个字符串的数组<br>colors.length=2;<br>alert(color[2]);    //undefined</p><p>利用length属性直接在数组末尾添加新项<br>var colors=[“red”,”green”,”black”];<br>colors[colors.length]=”yellow”;<br>alert(colors.length);//4</p><p>当把一个值放在超出数组大小的位置上，数组会重新计算其长度，即长度值等于最后一项的索引加1<br>var colors=[1,2,3];<br>var color[99]=9009;<br>alert(colors.length);//100  4-99都为undefined</p><h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>instanceof操作符的问题<br>if(value instanceof Array){<br>    //对数组执行某些操作<br>}</p><p>instanceof操作符的问题在于，它假定单一的全局执行环境，如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数，如果从一个框架向另一个框架传入数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。<br>新增Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。<br>if(Array.isArray(value)){<br>    //对数组执行某些操作<br>}</p><p>操作方法：<br>栈方法：push() pop() //push() 和pop()都是返回数组长度的<br>队列shift()队头取出 push()队尾插入    //shift() unshift() 都是返回数组长度的<br>unshift()队头插入 pop()对尾排出<br>重排序reverse() sort() -&gt;使用方法<br>var testSort=[3,1,2,2,7,4,5];<br>function addSort(a,b){<br>    return a-b;    //返回负值即a &lt; b; 返回0即相等 返回正值即a&gt;b;<br>}<br>alert(testSort.sort(addSort));    //1,2,2,3,4,5,7<br>alert(testSort.reverse());    //翻转数组<br>function ()<br>var obj=[“black”,”blue”,]<br>concat()基于当前数组中所有项创建一个新数组<br>var testConcat=obj.concat(“sb”,”yellow”);    //testConcat为 black、blue、sb、yellow<br>slice()能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一个或两个参数，即要返回项的起始和结束位置。<br>var test1Sort=testSort.slice(1,4);    //复制给test1Sort的值为第二个到第四个 1,2,3<br>slice()里面可以使用负数，与整数相同，意思就是不会取后面数值的那位数，是在此之前的。<br>如果结束位置小于起始位置，则返回空数组<br>splice()方法，主要用途是向数组的中部插入项<br>删除：可以删除任意数量项，两个参数，要删除额的第一项位置和要删除的项数(直接在数组上执行该函数，可以将这数组区间赋值给其他数组)<br>插入: 指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）要插入的项数<br>替换：splice(0,2,”blue”,”black”);将原有前两个删除，替换成blue和black</p><p>位置方法：数组实例添加两个位置方法:indexOf()和lastIndexOf()<br>都接受两个参数：要查找的项、起点位置索引<br>var number=[1,2,3,4,5,4,3,2,1];<br>console.log(number.indexOf(4));    //3<br>console.log(number.lastIndexOf(4));    //5<br>console.log(number.indexOf(4,4));    //5<br>console.log(number.lastIndexOf(4,3));    //4<br>返回的是在数组中的位置</p><p>5个迭代方法：每个方法都接受两个参数：要在每一项运行的函数和(可选的)运行该函数的作用域对象————影响this值。传入这些方法中的函数接受三个参数：数组项的值、该项在数组中的位置和数组对象本身。</p><ul><li>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true,则返回true</li><li>filter():运行给定函数，返回true的项组成的数组</li><li>forEach()：对数组中的每一项都运行给定函数，没有返回值，本质上与使用for循环迭代数组一样</li><li>map()：对数组中每一项运行给定函数。返回每次函数调用的结果组成的数组</li><li>some():对数组的每一项运行给定函数，如果该函数对任一项返回true，则返回true<br>以上方法都不会修改原数组包含的值<br>var number=[1,2,3,4,5,4,3,2,1];<br>  var everyResult=number.every(function(item,index,array){<pre><code>console.log(item);    //1console.log(index);    //0console.log(array);    //[1,2,3,4,5,4,3,2,1]return(item&gt;2);    //false</code></pre>  })<br>  console.log(everyResult);    //false<br>var someResult=number.some(function(item,index,array){<br>  return (item&gt;2);    //true<br>})<br>forEach\map\every\some\filter</li></ul><p>缩小方法：reduce()和reduceRight()。两个方法都会迭代数组的所有项，然后返回一个最终返回的值。要在新的变量上做不会改变原有变量的。<br>reduce()方法从数组的第一项开始，逐个遍历到最后，而reduceRight()从数组的最后一项开始，向前遍历到第一项<br>都接收两个参数：一个在每一项上调用的函数和(可选的)作为缩小基础的初始值。<br>上诉函数接受4个值：前一个值、当前值、项的索引、数组对象<br>这个函数返回的任何值都会作为第一个参数自动传给下一项，第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项<br>将values数组中所有值相加<br>var values=[1,2,3,4,5,4,3,2,1];<br>var sum=values.reduce(function(prev,cur,index,array){<br>    return prev+cur;<br>});<br>var sumRight=values.reduceRight(function(prev,cur,index,array){<br>    retrun prev+cur;<br>})<br>console.log(sum);    //25<br>console.log(sumRight);    //25</p><h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><p>两种方法：<br>date.parse() dete.UTC();</p><p>日期格式化方法<br>Date类型有一些专门用于将日期格式化为字符串的方法<br>toDateString()–以特定于实现的格式显示星期几、月、日、年<br>toTimeString()–格式显示时、分、秒和地区<br>toLocaleDateString()–格式显示地区星期几、月、日和年<br>toLocaleTimeString()–实现格式显示时、分、秒<br>toUTCString()–特定于实现的格式完整的UTC日期<br>toLocaleString()和toString()方法一样，以上字符串格式方法的输出也是浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息</p><h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><p>ECMAScript通过RegExp类型支持正则表达式<br>语法：<br>var expression =/pattern/ flags;<br>其中pattern部分可以使任何简单的或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志(flags)，用以表明正则表达式的行为。正则表达式的匹配模式支持下列3个标志<br>g:表示全局(global)模式,即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止<br>i:表示不区分大小写(case-insensitive)模式<br>m:表示多行(multiline)模式，即在到达一行文本末尾时还会继续查找下一行是否存在于，模式匹配的项<br>因此，一个正则表达式就是一个模式与上诉3个表示的组合体，不同组合产生不同结果</p><h3 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h3><p>行定位符(^和&amp;)<br>“^”表示行的开始 ，(&amp;)表示行的结束</p><p>单词定界符(\b,\B)<br>\b表示的是一个完整的单词<br>\btm\b     就只是寻找tm单词，不是单词的一部分，就是不能匹配html等<br>\Btm\B     匹配的字符串不是一个完整的单词，而是其他单词或字符串</p><p>字符类([])<br>[bac]at 就是可以匹配 bat、aat、cat 每个[]只能匹配一个字符</p><p>选择字符(|)<br>T|tM|m     就是可以匹配T/t后接一个M/m</p><p>连字符(-)<br>[a-zA-Z] 字符可以为全部小写字母加全部大写字母</p><p>排除字符([^])<br>[^a-zA-Z]    该表达式表达就是不以字母开头和下划线开头的变量名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">限定符(?*+&#123;n,m&#125;)</span><br><span class="line">? 匹配前面的字符零次或一次colou?r 可以匹配color colour</span><br><span class="line">* 匹配前面的字符零次或多次go*gle 可以匹配到ggle gogle google gooogle 类推</span><br><span class="line">+ 匹配前面的字符一次或多次  go+gle 可以匹配到gogle google gooogle 类推 </span><br><span class="line">&#123;n&#125; 匹配前面的字符n次go&#123;2&#125;gle  只能匹配到google</span><br><span class="line">&#123;n,&#125; 匹配前面的字符至少n次  go&#123;2,&#125;gle 至少匹配到google gooogle</span><br><span class="line">&#123;n,m&#125; 匹配前面的字符n次到m次 go&#123;2,20&#125;gle 就是匹配到google、到20个o都可以匹配到</span><br></pre></td></tr></table></figure><p>点号字符(.)<br>(.)可以匹配换行符之外的任意一个字符</p><p>转义字符()<br>将特殊字符(“.”,”\”,”?”)变为普通字符</p><p>反斜线()</p><p>反向引用<br>如要匹配两个it<br>(it)\1 这就可以匹配两个it</p><h2 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a>RegExp实例属性</h2><p>RegExp每个属性都具有下列属性，通过这些属性可以缺德有关模式的各种信息<br>global：布尔型，表示是否设置了g标志<br>ignoreCase：布尔型，表示是否设置了i标志<br>lastIndex:整数，表示开始搜索下一个匹配项的字符位置，从0开始；<br>multiline：布尔型，表示是否设置了m标志<br>source：正则表达式额字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回<br>var regSammary=new RegExp(“/go+gle/“,”g”);<br>console.log(regSammary.global);    //true<br>console.log(regSammary.ignoreCase);    //false<br>console.log(regSammary.multiline);//fasle<br>console.log(regSammary.source);//go+gle</p><p>Function类型<br>没有重载，函数实际上也是对象，每个函数都Function的实例，而且有与其他引用类型一样具有属性和方法，由于函数时对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常是使用函数声明语法定义的<br>函数声明<br>function sum(num1,num2){<br>    return num1+num2;<br>}<br>函数表达式<br>var sum=function(num1,num2){<br>    return num1+num2;<br>};<br>第二个通过变量sum即可以引用函数。函数末尾有一个分号</p><p>以上代码首先定义了一个名为sum()的函数，用于求两个值的和，然后又声明了变量<br>function sum(num1,num2){<br>    return num1+num2;<br>}<br>var anotherSum=sum;<br>sum(2,5);<br>anotherSum(1,3);</p><p>函数声明与函数表达式<br>函数声明与函数表达式不同，解析器会率先读取函数声明，并在其执行环境任何代码之前就可以使用。至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行<br><!-- 函数声明 --><br>alert(sum(10,10));<br>function sum(num1,num2){<br>    return num1+num2;<br>}</p><!-- 函数表达式 --><p>alert(sum(10,10));<br>var sun=function(num1,num2){<br>    return num1,num2;<br>}<br>第二个会出现错误，原因在于函数位于一个初始化语句中，而不是一个函数声明，执行到alert()上时，解析器不会保存函数的引用，而且由于第一行代码就会导致”unexpected identifier”(意外标识符)错误。实际上也不会执行到下一行<br>除了什么时候可以通过变量访问函数这一点上不同，其他没什么差别</p><h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>因为ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。不仅可以像传递参数一样把一个函数传递到另一个函数，而且可以将一个函数作为另一个函数的结果返回。<br>function returnFunction(someFunction,someArgument){<br>    return someFunction(someArgument());<br>}<br>接受两个函数，返回someFunction(someArgument())的值;<br>function addNum(num1){<br>  if(num1&gt;0){<br>  return num1+arguments.callee(num1);<br>  }<br>  else{<br>        return 0;<br>  }<br>}<br>在函数内没有引用addNum()函数，所以无论引用函数时使用什么名字，都可以保证正常完成递归调用</p><h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><p>函数内部有两个属性arguments和this<br>arguments是一个类数组的对象，包含传入函数中的所有数组，虽然arguments主要用途是保存函数参数，但该对象还有一个属性callee，该属性是一个指针，指向拥有这个arguments对象的函数<br>    function recursion(num) {<br>        if (num &gt; 0) {<br>            return num + arguments.callee(num - 1);<br>        } else {<br>            return num;<br>        }<br>    }<br>    console.log(recursion(10));<br>    var anotherRecursion = recursion;//这里就是保留了原本recursion的指针，所以后面直接使用anotherRecursion还是会迭代</p><pre><code>recursion=function() {    return 0;}console.log(anotherRecursion(10)); //55console.log(recursion(10));//0</code></pre><h4 id="this属性"><a href="#this属性" class="headerlink" title="this属性"></a>this属性</h4><p>函数内部的另一个特殊对象就是this，this引用的是函数执行的环境对象——this值(当在网页的全局作用域中调用函数时，this对象引用的就是window)</p><p>函数的名字仅仅是一个包含指针的变量，及时是在不同的环境中执行，调用的函数对象还是一样的，因为指针指向的仍然是固定的函数<br>ES5规范化另一个函数的属性：caller。这个属性保存着调用当前函数的函数的引用，如果实在全局作用域中调用当亲函数，它的值为null<br>function outer(){<br>    inner();<br>}<br>function inner(){<br>    alert(inner.caller);<br>}<br>outer();    //会输出调用该函数的代码：function outer(){inner()};<br>inner.caller==arguments.callee.caller;</p><p>在严格模式先callee和caller都会出错</p><h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><p>函数是对象，因此函数也有属性和对象<br>每个函数都包含两个对象length prototype<br>length表示函数接受参数的个数<br>如前面的recursion.length; //1 参数为1</p><p>对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。诸如toString() valueOf()等函数实际上是保存在prototype名下，只不过是通过各自对象的实例访问<br>每个函数都包含两个非继承而来的方法：apply() 和call() 用途都是在特定的作用域中调用函数，实际上等于设置函数体内的this对象的值。<br>apply()接收两个参数，第一个为运行函数的执行环境、第二个是参数数组</p><p>使用apply() call() 函数<br>apply()函数接收两个参数，第一个参数是其中运行函数的执行环境，另一个为数组可以为arguments或者Array()的实例<br>call()函数与apply()差不多，就是第二参数要每一个都写上去<br>function sum(num1,num2){<br>    return num1,num2;<br>}<br>function sum1(num1,num2){<br>    return sum.apply(this,arguments);<br>}<br>function sum2(num1,num2){<br>    return sum.call(this,num1,num2);//必须每个参数都要写进去<br>}<br>其实apply()与call()是在前面说明this 就后面不同<br>传递函数并非apply()和call()的主要，真正强大的是能扩充函数赖以生存的作用域<br>function actioning(){<br>    alert(this.number);<br>}<br>var t=( number : 3 );<br>window.color = 4 ;<br>actioning();//this.number 函数中没有，到全局环境中寻找 4<br>actioning.apply(t);//t.number  3<br>actioning.apply(window);//4<br>actioning.call(t);//3</p><p>基本包装类型：<br>为了便于操作基本数据类型，提供了3个特殊的引用类型：String()、Boolean()、Number()<br>后台会执行类似的方法<br>1、创建String()实例<br>2、在实例上调用指定的方法<br>3、销毁这个实例<br>var debugString=new String(“测试”);<br>var k1=debugString.substring(2);<br>k1=null;</p><p>单体内置对象<br>Global、Math<br>其实所有在全局作用域定义的所有变量和函数都是Global对象的属性<br>eval()方法，只接受一个参数，即要执行的ECMAScript字符串<br>eval(“alert(‘hi’)”);<br>与alert(‘hi’);一样<br>当解析器发现代码中调用eval()方法时，会传入参数当实际ES语句来解析</p><p>Math对象<br>属性<br>Math.E<br>Math.LN10<br>Math.LN2<br>Math.LOG2E<br>Math.LOG10E<br>Math.PI<br>Math.SQRT1/2</p><p>Math.mix() Math.max() Math.round() Math.ceil() Math.floor() Math.random()<br>Math.random()方法返回介入0和1之间一个随机数，不包括0和1。<br>利用Math.random()从某个整数范围内随机选一个值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">值= Math.floor(Math.random()*可能值的总数+最小的可能值);</span><br><span class="line">var num=Math.floor(Math.random()*9+2);//从2到10</span><br><span class="line">总共9个值，最小值为2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function selectFrom(lowerValue,upperValue)&#123;</span><br><span class="line">var totleNum=upperValue-lowerValue+1;</span><br><span class="line">return Math.floor(Math.random()*totleNum+lowerValue);</span><br><span class="line">&#125;</span><br><span class="line">console.log(selectFrom(2,10));</span><br></pre></td></tr></table></figure></p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>对象在JavaScript中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象<br>引用类型与传统面向对象设置中的类相似，但实现不用<br>Object是一个基础类型，其他所有类型都从Object继承了基本的行文<br>Array类型是一组值的有序列表，同时还提供来操作和转化你这些值的功能<br>Date类型提供里有关日期和时间的信息，包括当前日期和时间以及相关的计算功能<br>RegExp是ECMAScript支持正则表达式的一个借口，提供了最基本的和一些高级的正则表达式<br>函数实际上是function类型的实例</p><h1 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h1><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><p>ECMAScript有两种属性数据属性和访问器属性</p><h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>数据属性包含了一个数据值的位置在这个位置可以读取和写入值，数据属性有4个描述其行为的特性<br>[[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，默认为true<br>[[Enumberable]]: 表示能否通过for-in属性循环返回属性 默认为true<br>[[Writable]]：表示能够修改属性的值<br>[[Value]]：包含这个属性的数据值。在读取属性值的时候，从这个位置度，写入属性值的时候，把新值保存在这个位置<br>var person={<br>    name:”Kevin”<br>};<br>创建一个name的属性，[[Value]]特性将被设置为”Kevin”<br>要修改属性默认的特性，必须使用Object.defineProperty()方法，该方法接受三个参数：属性所在对象、属性名字和一个描述符对象，描述符对象的属性必须是：configurable、enumberable、writable、value。设置一个或多个值，可以修改对应的特性值<br>var person={};<br>Object.defineProperty(person,”name”,{<br>    writable:false,<br>    value:”kevin”<br>});</p><p>alert(person.name);//kevin<br>person.name=”Grag”;<br>alert(person.name);//kevin<br>调用Object.defineProperty()方法时，如果不指定，默认情况下，configurable、enumberable、value、writable将为false，多数情况下，可能没有必要利用Object.definProperty()方法提供的这些高级功能。</p><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性不包含数据值：它们包含一堆getter、setter函数(不过，这两个函数都不是必须的)。<br>在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值，在写入访问器属性时，会带哦一年setter函数并传入新值，这个函数负责决定如何处理数据，访问器属性有如下4个特性<br>[[Configurable]]:表示能否通过delete删除属性从而重新定义函数，能否修改属性的特性，或者能否把属性修改为数据属性<br>[[Enumberable]]:能否通过for-in循环返回属性，对于直接在队形上定义的属性，这个特性的默认值为true<br>[[Get]]：读取属性调用的函数，默认为undefined<br>[[Set]]：写入属性调用的函数，默认为undefined</p><p>访问器属性不能直接定义，必须使用Object.defineProperty()来定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var book=&#123;</span><br><span class="line">year:2005,</span><br><span class="line">edition:2</span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(book,&quot;year&quot;.&#123;</span><br><span class="line">get:function()&#123;</span><br><span class="line">return this.year;</span><br><span class="line">&#125;</span><br><span class="line">set:function()&#123;</span><br><span class="line">this.year=newValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>上述都是定义某一个属性的，但经常使用的是为对象定义多个属性<br>Object.defineProperties()<br>定义的前面的下划线是一种常用的标记，用于表示只能通过对象方法访问的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var book=&#123;&#125;;</span><br><span class="line">Object.defineProperties(book,&#123;</span><br><span class="line">_year:&#123;</span><br><span class="line">value:2018</span><br><span class="line">&#125;,</span><br><span class="line">name:&#123;</span><br><span class="line">value:4</span><br><span class="line">&#125;,</span><br><span class="line">year:&#123;</span><br><span class="line">get:function()&#123;</span><br><span class="line">return year;</span><br><span class="line">&#125;,</span><br><span class="line">set:function()&#123;</span><br><span class="line">if()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><p>Object.getOwnPropertyDescriptor()，取得给定属性的描述符<br>接收两个参数：属性所在对象和读取其描述符的属性名称，返回值是一个对象。如果是访问器属性，有configurable、value、enumberable、writable。数据属性<br>var desciptor=Object.hasOwnPropertyDescriptor(book,”year”);<br>console.log(descriptor.value);    //2018<br>console.log(descriptor.writable);//true</p><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>因为Object()构造函数或对象字面量都可以用来创建单个对象，但有个明显的缺点：使用同一个接口创建很多对象，会产生大量重复代码。为此，使用工厂模式的一种变体</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>发明一种函数，用函数来封装特定接口创建对象的细节<br>function createPerson(name,age,job){<br>    var o=new Object();<br>    o.name=name;<br>    o.age=age;<br>    o.job=job;<br>    o.sayName=function(){<br>        alert(this.name);<br>    };<br>    return o;<br>}<br>var person1=creatPerson(“Nicholas”,29,”hardwork”);<br>var person2=creatPerson(“kevin”,30,”easywork”);</p><p>function Person(name,age,job){<br>    this.name=name;<br>    this.age=age;<br>    this.job=job;<br>    this.sayName=function(){<br>        return name;<br>    }<br>}<br>var person1=new Person(“xiaoming”,5,”student”);<br>Person使用大写字母，惯例是构造函数都应该以一个大写字母开头，而非构造函数则应该以一个小写字符开头，主要是为了区别ECMAScript函数，因为构造函数本身也是函数，只不过可以用来创建对象而已<br>步骤：<br>(1)创建一个新对象<br>(2)将执行构造函数的作用域赋给新对象<br>(3)执行构造函数中的代码<br>(4)返回新对象<br>person1对象有一个constructor(构造函数)属性，该属性指向Person函数</p><p>将构造函数当做函数<br><!-- 当做普通函数 --><br>window.Person();<br><!-- 当做构造函数 --><br>var obj=new Person(“name”,20,”planning”);<br>alert(obj.name);//name<br><!-- 在另一对象域中调用 --><br>var o=new Object();<br>Person.call(o,”kevin”,20,”doctor”);<br>o.sayName();</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>创建的每一个函数都有proproperty属性，这个属性是一个指针，指向一个对象，而这个对象的用途是可以包含由特定类型的所有实例共享的属性和方法，如果按照字面意思来理解，nameproperty就是通过调用构造函数而创建的那个对象实例的原型对象，使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。<br>function Person(){};<br>Person.property.name=”kk”;<br>Person.property.age=12;<br>Person.property.job=”job”;<br>Person.property.sayName=function(){<br>    alert(this.name);<br>}</p><p>实例与原型<br><!-- 原型 --><br>function Person(){};<br>Person.property.name=”kk”;<br>Person.property.age=12;<br>Person.property.job=”job”;<br>Person.property.sayName=function(){<br>    alert(this.name);<br>}<br>person1=new Person();<br>person1.hasOwnProperty(“name”);//false 没有实例<br>alert(name in person1);</p><!-- 关于Object.getPrototypeOf --><p>Constructor hasOwnProperty isPrototypeOf propertyIsEnumberable<br>Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值<br>alert</p><p>//体现了原型与实例的差别<br>function Person(){};<br>    Person.prototype.name=”JK”;<br>    Person.prototype.age=20;<br>    Person.prototype.job=”Softwart Enginer”;<br>    Person.prototype.sayName=function(){<br>        alert(this.name);<br>    }</p><pre><code>var person1=new Person();console.log(person1.hasOwnProperty(&quot;name&quot;));//falseconsole.log(person1.name);//JK   person1.name=&quot;BB&quot;;//实例   delete person1.name//删除实例属性</code></pre><p>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性，及时将这个属性设置为null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过使用delete操作符可以完全删除实例属性</p><h2 id="原型与in操作符"><a href="#原型与in操作符" class="headerlink" title="原型与in操作符"></a>原型与in操作符</h2><p>有两种方式使用in操作符：单独使用和在for-in循环中使用，在单独使用时，in操作符会在通过对象访问属性时返回true，无论该属性存在实例中还是原型中。</p><p>var person1 = new Person();<br>var person3= new Person();</p><p>console.log(person1.hasOwnProperty(“name”))//false<br>console.log(“name” in person1);//true</p><p>person1.name=”Kevin”;<br>console.log(person1.hasOwnProperty(“name”))//true<br>console.log(“name” in person1);//true</p><p>说明了无论来自原型还是实例，都可以单独使用in来确定对象中是否存在该属性<br>name属性要么是直接在对象中访问到，要么是在实例上访问到的</p><p>同时用hasOwnProperty和in可以确定属性是在原型中还是实例中<br>function hasPrototypeProperty(object,name){<br>    return (object.hasOwnProperty &amp;&amp; “name” in object);//true为实例，false为原型<br>}</p><p>使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的属性，其中既包含存在实例中的属性，也包含了原型中的属性。屏蔽了原型中不可枚举属性的实例属性也会在for-in循环中返回，所有开发人员定义的属性都是可枚举的————只有在IE8即更早版本中例外。<br>Object.keys()方法 ——取得对象上所有可枚举的实例属性，接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数据<br>Object.keys(对象)返回对象中所有能被枚举的实例属性<br>function KeyReturn(){};<br>KeyReturn.name=”pan”;<br>KeyReturn.age=12;<br>KeyReturn.job=”teacher”;<br>KeyReturn.number=20151291911;<br>var obj=new KeyReturn();<br>Object.keys(obj);</p><p>4 原型的动态性<br>由于在原型中查找值的过程是一次搜索，因此我们队原型对象所做的任何修改都能够立即从实例上反映出来————及时是先创建了实例后修改原型也照样如此</p><p>组合使用构造函数模式和原型模式<br>创建自定义类型的最常见方法，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。每个实例都会有自己的一份实例属性的副本，但同时又共享对方法的引用，最大节省内存</p><h2 id="创建对象-1"><a href="#创建对象-1" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h3><pre><code>function factoryMethod(name, job, age) {    var o = new Object();    o.name = name;    o.job = job;    o.age = age;    o.sayHello = function() {        console.log(o.name);    };    return o;}var person1 = factoryMethod(&quot;kevin&quot;, &quot;soft&quot;, 21);var person2 = factoryMethod(&quot;Greg&quot;, &quot;soft&quot;, 21);</code></pre><h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><pre><code>// 构造函数console.log(&quot;构造函数&quot;);function constructor(name, job, age) {    this.name = name;    this.job = job;    this.age;    this.sayHello = function() {        console.log(this.name);    }}var personC1 = new constructor(&quot;kevin&quot;, &quot;soft&quot;, 21);personC1.sayHello();var personC2 = new constructor(&quot;Greg&quot;, &quot;soft&quot;, 21);personC2.sayHello();</code></pre><h3 id="原型函数模式"><a href="#原型函数模式" class="headerlink" title="原型函数模式"></a>原型函数模式</h3><pre><code>// 原型函数function prtMethod() {};prtMethod.prototype.name = &quot;JJD&quot;;prtMethod.prototype.age = 23;prtMethod.prototype.job = &quot;teacher&quot;;prtMethod.prototype.sayHello = function() {    console.log(this.name);}var personP1 = new prtMethod();console.log(&quot;原型函数为&quot; + personP1.name);</code></pre><h3 id="组合函数模式"><a href="#组合函数模式" class="headerlink" title="组合函数模式"></a>组合函数模式</h3><pre><code>// 组合函数console.log(&quot;组合函数&quot;);function mixMethod(name, job, age) {    this.name = name;    this.job = job;    this.age = age;}function mixMethod() {    mixMethod.prototype.sayHello = function() {        console.log(this.name);    }}var personM = new mixMethod(&quot;jake&quot;,&quot;kidding&quot;,32);personM.sayHello();</code></pre><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><pre><code>// 动态原型模式function activeMethod(name, job, age) {    this.name = name;    this.age = age;    this.job = job;    if ( typeof this.sayHello != &quot;function&quot;) {        activeMethod.prototype.sayHello = function() {            console.log(this.name);        }    }}var personA=new activeMethod(&quot;Giek&quot;,&quot;78&quot;,&quot;Old Man&quot;);personA.sayHello();</code></pre><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><pre><code>// 以上模式都不适用的情况下// 基本思想：创建一个函数，仅仅是封装创建对象的代码，然后再返回新创建的对象// 除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例，而通过在构造函数为末尾添加一个return语句，可以重写嗲用构造函数时返回的值// 这个函数可以在特殊情况下用来为对象创建构造函数。function Parasitic(name, job, age) {    var o = new Object();    o.name = name;    o.job = job;    o.age = age;    o.sayHello = function() {        console.log(o.name);    }    return o;}var personPar=new Parasitic(&quot;qb&quot;,32,&quot;doctor&quot;);/** * [SpecialArray description]利用寄生构造函数  * 常见一个额外方法的特殊数组，因为不能直接修改Array()函数，因此可以使用这个模式 * 返回的对象与构造函数或者与构造函数的原型属性之间没有关系 * 构造函数返回的对象与在构造函数外部创建的对象没有什么不同，为此不能依赖instanceof操作符来确定对象类型 */function SpecialArray(){    // 创建数组    var values=new Array();    // 添加值    values.push.apply(values,arguments);    // 添加方法    values.toPipedString=function(){        return this.join(&quot;|&quot;);    };    // 返回数组    return values;}var colors=new SpecialArray(&quot;red&quot;,&quot;blue&quot;,&quot;black&quot;);console.log(colors.toPipedString());</code></pre><h3 id="稳妥构造啊函数模式"><a href="#稳妥构造啊函数模式" class="headerlink" title="稳妥构造啊函数模式"></a>稳妥构造啊函数模式</h3><pre><code>/** * 稳妥构造函数模式 * 没有使用new和this，保证了调用方法的安全性，就像例子中的一样，只能调用sayHello()方法来调用name * 所谓稳妥对象，指的是没有公共属性，稳妥对象最适合在一些安全的环境中。 * @param  {[type]} name [string] * @param  {[type]} job  [string] * @param  {[type]} age  [string] * @return {[type]}      [object] */function safeMethod(name,job,age){    var o=new Object();    o.sayHello=function(){        console.log(name);    }    return o;}</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ECMAScript只支持实现继承，实现继承主要是依靠原型链来实现的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 原型链 下面SubType的prototype指向SuperType.prototype，instance指向SubType.prototype</span><br><span class="line">     * 所有的对象都是继承Object所有Object()属性方法各种函数都是有的，Constructor、hasOwnProperty、prototypeIsEnumberable、isPrototypeOf、toLocaleString、toString、valueOf</span><br><span class="line">     */</span><br><span class="line">    function SuperType()&#123;</span><br><span class="line">    this.prototype=true;</span><br><span class="line">    SuperType.prototype.getValue=function()&#123;</span><br><span class="line">    return this.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function SubType()&#123;</span><br><span class="line">    this.subprototype=false;</span><br><span class="line">    &#125;</span><br><span class="line">    SubType.prototype=new SuperType();</span><br><span class="line">    SubType.prototype.getSubValue=function()&#123;</span><br><span class="line">    return this.subprototype;</span><br><span class="line">    &#125;;</span><br><span class="line">    var instance=new SubType();</span><br><span class="line">    console.log(instance.getSubValue());</span><br><span class="line">    console.log(instance.getValue());</span><br></pre></td></tr></table></figure></p><p>所有引用类型默认继承了Object，而这个继承也是通过原型链实现的。<br>2、认定原型和实例的关系<br>第一种方法是使用instanceof操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，使用和这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true<br>console.log(instance instanceof SuperType);//true<br>console.log(instance instanceof SubType);//true<br>console.log(instnace isntnaceof SubType);//true</p><p>由于原型链的关系，可以说instance是SubType、SuperType、Object的实例<br>第二种方法<br>isPrototypeOf()方法，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型<br>console.log(instance isPrototype Object);//true<br>console.log(instance isPrototype SuperType);//true<br>console.log(instance isPrototype SubType);//true</p><p>3、谨慎地定义方法<br>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法<br>在通过原型链实现继承时，不能使用对象字面量创建原型方法，这样会重写原型链的</p><p>4、原型链的问题<br>最主要的问题来自包含引用类型值的原型，前面介绍过包含引用类型值的原型属性会被所欲实例共享;而这也正是为什么要在构造函数中，而不是原型对象中定义属性的原因<br>(简单的说就是在原型链中定义的，后面实例继承后，原型中所有属性都会继承到实例中)<br>第二个问题：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说没有办法在不影响所有对象实例的情况下，在超类型的构造函数传递参数，有鉴于此。在</p><h1 id="小引用与小总结"><a href="#小引用与小总结" class="headerlink" title="小引用与小总结"></a>小引用与小总结</h1><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>执行上下文的生命周期可以分为两个阶段</p><ol><li>创建阶段 执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向</li><li>代码执行阶段 创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码</li></ol><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><h4 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h4><p>1、建立arguments对象，检查当前上下文中的参数，建立该对象下的属性与属性值<br>2、检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用，如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖<br>3、检查当前上下文的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined,则会直接跳过，原属性值不会修改<br>注意上面说得都是在创建阶段上，还没有到代码执行阶段</p><p>然后就是代码执行阶段了<br>未进入执行阶段之前，变量对象都不能进行访问，但是进入执行阶段之后，便利康对象转变为活动对象，里面的属性就能访问了，然后开始进行执行阶段的操作<br>变量对象与活动对象：<br>其实都是同一个对象，只是执行上下文的不同生命周期，不过只有处于函数调用栈栈顶的执行上下翁中的变量对象，才会变成活动对象</p><h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><p>作用域</p><ul><li>在JavaScript中，可以将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找(标识符指的是变量名或者函数名)</li><li>JavaScript中只有全局作用域与函数作用域(eval在平时开发中很少用到)</li><li>作用域与执行上下文时完全不同的两个概念，一定要仔细区分<blockquote><p>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段，编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定，执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</p></blockquote></li></ul><p>作用域链<br>是由当前环境与上层环境的一系列变量对象组成，它保证了当前环境对符合访问权限的变量和函数的有序访问<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> b=a+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">innerTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> c=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> innerTest();</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * innerTestEC=&#123;</span></span><br><span class="line"><span class="comment"> * VO:&#123;...&#125;;//变量对象</span></span><br><span class="line"><span class="comment"> * scopeChain:[VO(innnerTest),VO(test),VO(global)];</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * 直接使用一个数组表示作用域链，数组的第一项scopeChain[0]作为作用域链的最前端，而数组的最后一项，为作用域端的最末端，所有的最末端都为全局变量对象</span></span><br><span class="line"><span class="comment"> * 很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是，以最前端为七点，最末端为重点的单方向通道是更为贴切的形容</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是一种特殊的对象<br>由两部分组成，执行上下文(代号A)，以及在该执行上下文中创建的函数(代号B)<br>当B执行时，如果访问了A中变量对象的值，那么闭包就产生。<br>在大多数理解中，包括许多著名的书籍，文章里都以函数B的名字呆滞这里生成的闭包，而在Chrome中，则以执行上下问的函数名呆滞闭包<br>因此我们只需要知道，一个闭包对象，由A、B共同组成的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> bar;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> bar = foo();</span><br><span class="line">    bar();</span><br></pre></td></tr></table></figure></p><p>使用chrome调试工具得出的结果是上面的函数中，闭包为foo()，就是说是以执行上下文的函数名来作为闭包名称，其实是两个合在一起的，执行上下文和执行上下文中创建的函数的调用执行上下文的变量对象，执行上下文A和执行上下文创建的函数B。B调用了A的变量对象就产生了闭包</p><p>首先有执行上下文，在foo中定义了函数bar，而通过对外返回bar方式让bar得以执行，当bar执行时，访问foo内部的变量a,b。因此这个时候闭包产生<br>我们知道，函数的执行上下文，执行完毕之后，生命周期结束，该函数的执行上下文就会失去引用，其占用的内存空间很快就会被垃圾回收期释放，可是闭包的存在，会阻止这一过程</p><p>闭包有两个非常重要的应用情景。分别是模块化、柯里化</p><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>在函数式编程中，利用闭包能够实现很多炫酷的功能，柯里化就是其中一种，详细查阅资料后再补充<br>把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数而且返回结果的新函数的技术<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*a+b*b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">调用为(foo(<span class="number">3</span>))(<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p><h3 id="this解析"><a href="#this解析" class="headerlink" title="this解析"></a>this解析</h3><p>创建执行上下文，知道执行上下文会有两个生命周期，创建阶段和代码执行阶段。创建阶段是创建变量对象，建立作用域链，确定this指向。代码执行阶段是变量赋值，函数引用，执行其他代码</p><blockquote><p>得出一点，this的指向，是在函数被调用的时候被确定的，也就是执行上下文被创建时确定的，因此一个函数中this的指向是非常灵活的</p></blockquote><p>var a=10;<br>var obj = {<br>    a:20<br>}<br>function fn(){<br>    console.log(this.a);<br>}<br>fn();//10<br>fn.call(obj);//20<br>除此之外，在函数执行过程中，一旦this被确定就不能更改</p><p>var a=10;<br>var obj={<br>    a:20<br>}<br>function fn(){<br>    this=obj;//抛出错误，在构建函数时，this已经确定了<br>    console.log(this.a);<br>}</p><p>一、全局对象中的this<br>关于全局对象this，会指向自己，相对复杂</p><p>二、函数中的this<br>如果调用者函数，被某一对象所拥有，那么该函数在调用时，内部的this指向该对象，如果函数独立调用，那么该函数内部的this，则指向undefined，在非严格模式下，指向的是全局对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> obj = &#123;</span><br><span class="line">            a: <span class="number">10</span>,</span><br><span class="line">            c: <span class="keyword">this</span>.a + <span class="number">20</span>,</span><br><span class="line">            fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj.c;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(foo()); <span class="comment">//  chrome会抛出错误</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.foo()); <span class="comment">// 40</span></span><br></pre></td></tr></table></figure></p><blockquote><p>实际开发中，不推荐这样使用this<br>严格模式必须要掌握，因为在实际开发中，现在进本已经全部采用严格模式，最新的ES6也是默认支持严格模式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">        console.log(this.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function active(fn) &#123;</span><br><span class="line">        fn(); // 真实调用者，为独立调用 fn在这个例子中就是obj.getA直接调用方法，没有对象，所以就导致了直接调用foo没有没有局部对象</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var a = 20;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">        a: 10,</span><br><span class="line">        getA: foo</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    active(obj.getA);//20与直接调用foo的方法是同义的</span><br></pre></td></tr></table></figure><p>三、使用call、apply显示指定this<br>javascript内部提供一种机制，我们可以自行手动设置this的指向，call与apply。所有的函数都有着两个方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//熟悉arguments</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">exam</span>(<span class="params">a,b,c,d,e</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> arg=[].slice.call(<span class="built_in">arguments</span>);<span class="comment">//将arguments转换为数组</span></span><br><span class="line">        <span class="built_in">console</span>.log(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    exam(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 常使用[].slice.call(docuement.getElementsByTagName("li"))转换成数组;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父级的构造函数</span></span><br><span class="line">    <span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"kevin"</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">this</span>.gender = [<span class="string">'man'</span>, <span class="string">'woman'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义子类的构造函数</span></span><br><span class="line">    <span class="comment">//实现了继承</span></span><br><span class="line">    <span class="keyword">var</span> Student = <span class="function"><span class="keyword">function</span>(<span class="params">name, age, high</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use call</span></span><br><span class="line">        Person.call(<span class="keyword">this</span>, name, age);<span class="comment">//进入了Person的执行上下文，使用this.gender，将数组赋值给了Student对象</span></span><br><span class="line">        <span class="comment">//即实现了Student继承Person对象</span></span><br><span class="line">        <span class="keyword">this</span>.high = high;</span><br><span class="line">    &#125;</span><br><span class="line">    Student.prototype.message = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'name:'</span> + <span class="keyword">this</span>.name + <span class="string">', age:'</span> + <span class="keyword">this</span>.age + <span class="string">', high:'</span> + <span class="keyword">this</span>.high + <span class="string">', gender:'</span> + <span class="keyword">this</span>.gender[<span class="number">0</span>] + <span class="string">';'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Student(<span class="string">'xiaom'</span>, <span class="number">12</span>, <span class="string">'150cm'</span>).message();</span><br></pre></td></tr></table></figure><p>在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码。在Student中复制了一次，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person(name,age)&#123;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line"><span class="keyword">this</span>.name=age;</span><br><span class="line"><span class="keyword">this</span>.generate=[<span class="string">"man"</span>,<span class="string">"woman"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Student(name,age,generate)&#123;</span><br><span class="line">Person.call(<span class="keyword">this</span>,name,age);</span><br><span class="line"><span class="keyword">this</span>.generate=generate;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.message()&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name:"</span>+<span class="keyword">this</span>.name+<span class="string">"age:"</span>+<span class="keyword">this</span>.age+<span class="string">"generate"</span>+<span class="keyword">this</span>.generate);</span><br><span class="line">&#125;</span><br><span class="line">Student(<span class="string">"kevin"</span>,<span class="number">12</span>).message();</span><br></pre></td></tr></table></figure></p><p>call/apply实际应用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">var</span> obj=&#123;</span><br><span class="line">        a:<span class="number">10</span>,</span><br><span class="line">        getA:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">            &#125;,<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj.getA();<span class="comment">//20</span></span><br></pre></td></tr></table></figure></p><p>这个我们是希望this是指向obj的，但是由于匿名函数的原因，导致了this指向了全局环境<br>解决方法：<br>常规方法是使用一个变量将this引用保存起来<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">a:<span class="number">10</span>,</span><br><span class="line">getA:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> self=<span class="keyword">this</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(self.a);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getA();<span class="comment">//10</span></span><br></pre></td></tr></table></figure></p><p>借助闭包与apply方法，封装一个bind方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bind(fn,obj)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fn.apply(obj,argument);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">a:<span class="number">10</span>,</span><br><span class="line">getA:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">setTimeout(bind(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;,<span class="keyword">this</span>),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getA();</span><br></pre></td></tr></table></figure></p><p>this,是在函数调用过程中确定的，因此，搞明白new的过程中到底发生了什么变得非常中国要<br>通过new操作符调用构造函数，会经历一下4个阶段：</p><ul><li>创建一个新的对象</li><li>将构造函数的this指向这个对象</li><li>指向构造函数的代码，为这个对象添加属性，方法等</li><li>返回新对象</li></ul><p>当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象接收，因此，可以说构造函数的this指向的新的实例对象p1<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;<span class="comment">//this会指向实例对象</span></span><br><span class="line">        <span class="keyword">this</span>.age=age;<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    obj.prototype.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> k=<span class="keyword">new</span> obj(<span class="string">"test"</span>,<span class="number">12</span>);<span class="comment">//这个调用就会将test赋值给this.name this.age</span></span><br><span class="line">    k.getName();</span><br></pre></td></tr></table></figure></p><h2 id="函数与函数式编程"><a href="#函数与函数式编程" class="headerlink" title="函数与函数式编程"></a>函数与函数式编程</h2><p>函数声明、函数表达式、匿名函数与自执行函数<br>函数声明<br>function foo(name,age,job){<br>    this.name=name;<br>    this.age=age;<br>    this.job=job;<br>}<br>函数表达式<br>var foo =function(name,age,job){<br>    this.name=name;<br>    this.age=age;<br>    this.job=job;<br>}<br>匿名函数<br>没有被显示进行赋值操作的函数，使用场景，多数作为参数传入另一个函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> fn=<span class="function"><span class="keyword">function</span>(<span class="params">bar,num</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bar()+num);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;,<span class="number">20</span>);</span><br></pre></td></tr></table></figure></p><p>fn的第一个参数传入了一个匿名函数，虽然该匿名函数没有显示的进行赋值操作，我们没有办法爱外部执行上下文中引用到它，但是在fn函数内部，我们将该匿名函数赋值给了bar，保存在了fn的arguments对象中<br>// 变量对象在fn上下文执行过程中的创建阶段<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VO(fn) = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        bar: <span class="literal">undefined</span>,</span><br><span class="line">        num: <span class="literal">undefined</span>,</span><br><span class="line">        length: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量对象在fn上下文执行过程中的执行阶段</span></span><br><span class="line"><span class="comment">// 变量对象变为活动对象，并完成赋值操作与执行可执行代码</span></span><br><span class="line">VO -&gt; AO</span><br><span class="line"></span><br><span class="line">AO(fn) = &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">        bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> a &#125;,</span><br><span class="line">        num: <span class="number">20</span>,</span><br><span class="line">        length: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于匿名函数传入另一个函数之后，最终会在另一个函数中执行，因此我们常称匿名函数为回调函数<br>匿名函数的这个应用场景几乎承担了函数的所有难以理解的知识点</p><p>函数自执行与块级作用域<br>在ES5，(不清楚ES6有没有)没有块级作用域，因此常使用函数自执行的方式来模仿块级作用域，提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础，而函数自执行其实就是匿名函数的一种应用</p><p>(function obj(){<br>    console.log(i);<br>    // …<br>})(i)<br>一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    // 私有变量</span><br><span class="line">    var age = 20;</span><br><span class="line">    var name = &apos;Tom&apos;;</span><br><span class="line"></span><br><span class="line">    // 私有方法</span><br><span class="line">    function getName() &#123;</span><br><span class="line">        return `your name is ` + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>利用闭包，可以访问到执行上下文内部的变量与方法，因此创建一个闭包，将认为需要公开的变量和方法开放出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">        //私有变量</span><br><span class="line">        var a=1;</span><br><span class="line">        var b=2;</span><br><span class="line">        //私有变量</span><br><span class="line">        function getA()&#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">        //公有变量</span><br><span class="line">        function getB()&#123;</span><br><span class="line">            return b;</span><br><span class="line">        &#125;</span><br><span class="line">        //将引用保存在外部执行环境的变量中，防止该执行环境被垃圾回收</span><br><span class="line">        window.getB=getB;</span><br><span class="line">    &#125;)()</span><br></pre></td></tr></table></figure></p><p>例子jQuery利用模块和闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(function(window,undefined)&#123;</span><br><span class="line">        //声明jQery构造函数</span><br><span class="line">        var jQuery=function(name)&#123;</span><br><span class="line">            //主动在构造函数中，返回一个jQery实例</span><br><span class="line">            return new jQery.fn.init(name);</span><br><span class="line">        &#125;</span><br><span class="line">        //添加原型方法</span><br><span class="line">        jQery.prototype=jQery.fn=&#123;</span><br><span class="line">            constructor:jQery,</span><br><span class="line">            init:function()&#123;...&#125;,</span><br><span class="line">            css:function()&#123;...&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jQery.fn.init.prototype=jQery.fn;</span><br><span class="line"></span><br><span class="line">        //将jQery改名为$，并将引用保存在window上，形成闭包，对外开发jQery构造函数，这样我们就可以访问所有挂载在jQery原型上的方法了</span><br><span class="line">        window.jQery=window.$=jQery;</span><br><span class="line">    &#125;)(window);</span><br><span class="line">    //</span><br><span class="line">    $(&quot;#div1&quot;);</span><br></pre></td></tr></table></figure></p><blockquote><p>非常有用的模块的应用。当我们的项目越来越大，那么需要保存的数据与状态就越来越多，因此，我们需要一个专门的模块来维护这些数据，这个时候，有一个叫做状态管理器的东西就应运而生。对于状态管理器，最出名的，我想非redux莫属了。虽然对于还在学习中的大家来说，redux是一个有点高深莫测的东西，但是在我们学习之前，可以先通过简单的方式，让大家大致了解状态管理器的实现原理，为我们未来的学习奠定坚实的基础<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">        // states 结构预览</span><br><span class="line">        // states = &#123;</span><br><span class="line">        //     a: 1,</span><br><span class="line">        //     b: 2,</span><br><span class="line">        //     m: 30,  </span><br><span class="line">        //     o: &#123;&#125;</span><br><span class="line">        // &#125;</span><br><span class="line">        var states = &#123;&#125;; // 私有变量，用来存储状态与数据</span><br><span class="line"></span><br><span class="line">        // 判断数据类型</span><br><span class="line">        function type(elem) &#123;</span><br><span class="line">            if (elem == null) &#123;</span><br><span class="line">                return elem + &apos;&apos;;</span><br><span class="line">            &#125;</span><br><span class="line">            return toString.call(elem).replace(/[\[\]]/g, &apos;&apos;).split(&apos; &apos;)[1].toLowerCase();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * @Param name 属性名</span><br><span class="line">         * @Description 通过属性名获取保存在states中的值</span><br><span class="line">         */</span><br><span class="line">        function get(name) &#123;</span><br><span class="line">            return states[name] ? states[name] : &apos;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function getStates() &#123;</span><br><span class="line">            return states;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * @param options &#123;object&#125; 键值对</span><br><span class="line">         * @param target &#123;object&#125; 属性值为对象的属性，只在函数实现时递归中传入</span><br><span class="line">         * @desc 通过传入键值对的方式修改state树，使用方式与小程序的data或者react中的setStates类似</span><br><span class="line">         */</span><br><span class="line">        function set(options, target) &#123;</span><br><span class="line">            var keys = Object.keys(options);</span><br><span class="line">            var o = target ? target : states;</span><br><span class="line"></span><br><span class="line">            keys.map(function(item) &#123;</span><br><span class="line">                if (typeof o[item] == &apos;undefined&apos;) &#123;</span><br><span class="line">                    o[item] = options[item];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    type(o[item]) == &apos;object&apos; ? set(options[item], o[item]) : o[item] = options[item];</span><br><span class="line">                &#125;</span><br><span class="line">                return item;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 对外提供接口</span><br><span class="line">        window.get = get;</span><br><span class="line">        window.set = set;</span><br><span class="line">        window.getStates = getStates;</span><br><span class="line">    &#125;)()</span><br><span class="line"></span><br><span class="line">    // 具体使用如下</span><br><span class="line"></span><br><span class="line">    set(&#123; a: 20 &#125;); // 保存 属性a</span><br><span class="line">    set(&#123; b: 100 &#125;); // 保存属性b</span><br><span class="line">    set(&#123; c: 10 &#125;); // 保存属性c</span><br><span class="line"></span><br><span class="line">    // 保存属性o, 它的值为一个对象</span><br><span class="line">    set(&#123;</span><br><span class="line">        o: &#123;</span><br><span class="line">            m: 10,</span><br><span class="line">            n: 20</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 修改对象o 的m值</span><br><span class="line">    set(&#123;</span><br><span class="line">        o: &#123;</span><br><span class="line">            m: 1000</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 给对象o中增加一个c属性</span><br><span class="line">    set(&#123;</span><br><span class="line">        o: &#123;</span><br><span class="line">            c: 100</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(getStates())</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="函数参数传递方法：按值传递"><a href="#函数参数传递方法：按值传递" class="headerlink" title="函数参数传递方法：按值传递"></a>函数参数传递方法：按值传递</h3><p>当值作为函数的参数传递进入函数内部时，有差异，函数参数在进入函数后，实际是被保存在了函数的变量对象中，因此这个时候相当于发生了一次复制。<br>var a=20;<br>function fn(a){<br>    a=a+10;<br>    return a;<br>}<br>按值传递，当我们期望传递一个引用类型时，真正传递的，只是这个引用类型保存在变量对象中的引用而已<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var person=&#123;</span><br><span class="line">        name:&quot;kk&quot;,</span><br><span class="line">        age:20</span><br><span class="line">    &#125;</span><br><span class="line">    function setName(obj)&#123;</span><br><span class="line">        obj=&#123;&#125;;</span><br><span class="line">        obj.name=&apos;gg&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    setName(person);</span><br><span class="line">    console.log(person.name);//kk</span><br></pre></td></tr></table></figure></p><p>如果person是按引用传递，那么person就会自动被修改为指向其name属性值为gg的新对象，但是从结果中看出，person对象并没有发生任何的改变，因此只是在函数内部引用被修改而已。</p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>要懂得利用编程式思维建议我们将这种多次出现的功能封装起来备用<br>例子：将数组中number中的项提取出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getNum(obj) &#123;</span><br><span class="line">        var res = [];</span><br><span class="line">        obj.forEach(function(item) &#123;</span><br><span class="line">            if (typeof item == &quot;number&quot;) &#123;</span><br><span class="line">                res.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">var op=[&quot;1&quot;,33,&quot;di&quot;,&quot;3&quot;,23,90];</span><br><span class="line">console.log(getNum(op));//[33,23,90]</span><br></pre></td></tr></table></figure></p><h2 id="函数式编程思维具有以下特征"><a href="#函数式编程思维具有以下特征" class="headerlink" title="函数式编程思维具有以下特征"></a>函数式编程思维具有以下特征</h2><h3 id="函数是第一等公民"><a href="#函数是第一等公民" class="headerlink" title="函数是第一等公民"></a>函数是第一等公民</h3><p>所谓”第一等公民”，指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值<br>可以直接赋值，传入函数，函数中返回函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function delay()&#123;</span><br><span class="line">        console.log(&quot;延迟5000秒显示&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    var timer=setTimeout(delay,5000);//直接使用函数</span><br><span class="line">    var timer=setTimeout(function()&#123;</span><br><span class="line">    delay();</span><br><span class="line">    &#125;,5000);///多此一举</span><br></pre></td></tr></table></figure></p><h3 id="只用”表达式”，不用语句"><a href="#只用”表达式”，不用语句" class="headerlink" title="只用”表达式”，不用语句"></a>只用”表达式”，不用语句</h3><p>“表达式”只是一个单纯的运算过程，总有返回值；<br>“语句”是执行某种操作，没有返回值。函数式编程，只使用表达式，不使用语句。每一步都是单纯的运算，而且都有返回值<br>函数式编程需要有输入，也要有输出</p><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>相同的输入总会得到相同的输出，这就是纯函数<br>所谓”副作用”，指的是函数内部与外部互动(最典型的例子，就是修改全局变量的值)，产生运算以外的其他结果。<br>函数式编程强调没有”副作用”，以为着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值<br>只要是同样的参数传入，返回的记过一定是相等的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">source.slice(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 纯函数 返回[2, 3] source不变</span></span><br><span class="line">source.splice(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 不纯的 返回[2, 3, 4] source被改变</span></span><br><span class="line"></span><br><span class="line">source.pop(); <span class="comment">// 不纯的</span></span><br><span class="line">source.push(<span class="number">6</span>); <span class="comment">// 不纯的</span></span><br><span class="line">source.shift(); <span class="comment">// 不纯的</span></span><br><span class="line">source.unshift(<span class="number">1</span>); <span class="comment">// 不纯的</span></span><br><span class="line">source.reverse(); <span class="comment">// 不纯的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我也不能短时间知道现在source被改变成了什么样子，干脆重新约定一下</span></span><br><span class="line">source = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">source.concat([<span class="number">6</span>, <span class="number">7</span>]); <span class="comment">// 纯函数 返回[1, 2, 3, 4, 5, 6, 7] source不变</span></span><br><span class="line">source.join(<span class="string">'-'</span>); <span class="comment">// 纯函数 返回1-2-3-4-5 source不变</span></span><br></pre></td></tr></table></figure></p><h3 id="柯里化-1"><a href="#柯里化-1" class="headerlink" title="柯里化"></a>柯里化</h3><p>柯里化是指这样一个函数(假设createCurry)接收函数A作为参数。运行后能够返回一个新的函数。并且这个新的函数能够处理函数A的剩余参数<br>假如有一个接收三个参数返回三个参加相加的函数A<br>function A(a,b,c){<br>    return a+b+c;<br>}<br>柯里化<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_A</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_A</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_A</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_A(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">_A(<span class="number">1</span>)(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">_A(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line">_A(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line">都是等价的</span><br></pre></td></tr></table></figure></p><p>可以看出，柯里化函数的运行过程其实是一个参数的收集过程，我们将每一次传入的参数手机起来，并在最里层里面处理。因此我们在实现createCurry时，可以借助这个思路来进行封装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function createCurry(func, args) &#123;</span><br><span class="line">        var arity = func.length;</span><br><span class="line">        var args = args || [];</span><br><span class="line"></span><br><span class="line">        return function() &#123;</span><br><span class="line">            var _args = [].slice.call(arguments);</span><br><span class="line">            [].push.apply(_args, args);</span><br><span class="line"></span><br><span class="line">            // 如果参数个数小于最初的func.length,则递归调用，继续收集函数</span><br><span class="line">            if (_args.length &lt; arity) &#123;</span><br><span class="line">                return createCurry.call(this, func, _args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 参数收集完毕，则执行func</span><br><span class="line">            return func.apply(this, _args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>柯里化就是将函数复杂化，但复杂化的同时，在使用函数时拥有了更加多的自由度，而这里对于函数参数的自由处理就是柯里化的核心</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>对象被定义为”无序属性的集合，其属性可以包含基本值，对象或者函数”<br>同时访问person的name与age<br>[‘name’,’age’].forEach(function(item){<br>    console.log(item);<br>})</p><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><p>结合构造函数与原型来创建一个对象，因为构造函数与原型的不同特性，分别解决了不同的困扰，根据构造函数与原型的不同采取不同的策略<br>声明一个Person对象，将这个对象作为腹肌，而自己cPerson将要继承Person的所有属性与方法<br>function Person(){<br>    this.name=name;<br>    this.age=age;<br>}<br>Person.prototype.getName=function(){<br>    return this.name;<br>}<br>//构造函数的继承<br>function cPerson(name,age,job){<br>    Person.call(this,name,age);<br>    this.job=job;<br>}<br>//原型函数的继承<br>cPerson.prototype=new Person();<br>//通过原型函数添加更多方法<br>cPerson.prototype.getMore=function(){<br>    return 19;<br>}</p><h3 id="更好的继承"><a href="#更好的继承" class="headerlink" title="更好的继承"></a>更好的继承</h3><p>通过前面原型链的学习我们知道，处于S端的对象，可以通过S -&gt; E的单向查找，访问到原型链上的所有方法与属性。因此这给继承提供了理论基础。我们只需要在S端添加新的对象，那么新对象就能够通过原型链访问到父级的方法与属性。因此想要实现继承，是一件非常简单的事情。</p><p>构造函数的继承比较简单，我们可以借助call/apply来实现，假如我们要通过继承封装一个Student的子类对象。那么构造函数可以如下来实现<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student=<span class="function"><span class="keyword">function</span>(<span class="params">number,year,grade</span>)</span>&#123;</span><br><span class="line">Student.call(<span class="keyword">this</span>,number,year);</span><br><span class="line"><span class="keyword">this</span>.grade=grade;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">var</span> Student=<span class="function"><span class="keyword">function</span>(<span class="params">number,year,grade</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.number=number;</span><br><span class="line"><span class="keyword">this</span>.year=year;</span><br><span class="line"><span class="keyword">this</span>.grade=grade;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现原型的继承</span></span><br><span class="line">Student.prototype = create(Person.prototype, &#123;</span><br><span class="line">    <span class="comment">// 不要忘了重新指定构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: Student</span><br><span class="line">    &#125;</span><br><span class="line">    getGrade: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.grade</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>es6中每个属性都有几个属性类型：<br>configurable：表示该属性能否被delete删除<br>enumberable：能否被for-in枚举<br>writable：能够被修改值<br>value:该属性的值为多少<br>set:调用属性的值<br>get:设置属性的值时被调用<br>需要注意的是:value set get不能被同时调用<br>可以通过Object.defineProperty方法来修改这些属性类型<br>function obj(name,job,age){<br>    this.name=name;<br>    this.age=age;<br>}<br>obj.prototype.getName=function(){<br>    return this.name;<br>}<br>Object.defineProperty(obj,’name’,{<br>    configurable:flase,<br>    value:’大哥’<br>})<br>delete obj.name;//不能删除<br>//因为configurable设置了不能删除<br>Object.defineProperty(obj,’age’,{<br>    enmberable:false;<br>})</p><p>Object.defineProperty只能设置一个属性不能设置多个属性<br>更改多个属性应该使用Object.defineProperties<br>Object.defineProperty(obj,{<br>    name:{<br>        value:’jack’,<br>        configuable:false<br>},<br>    age:{<br>        getAge:function(){<br>        return this.value||22;<br>    }<br>}<br>})</p><p>function test(name,age,job){<br>    this.name=name;<br>    this.age=age;</p><p>}<br>test.prototype.getName=function(){<br>    return this.name;<br>}<br>//更改一个属性的特性值<br>Object.defineProperty(test,’name’,{<br>    value:’jack’,<br>    configurable:false,<br>    enumberable:false<br>})<br>//更改多个属性的特性值<br>Object.defineProperty(test,{<br>    name:{<br>    value:’jack’,<br>    writable:false<br>},<br>    age:{<br>    configurable:false,<br>    writable:false,<br>    enumberable:false,<br>    value:12,</p><p>}<br>})<br>读取属性的特性值<br>使用Object.getOwnPropertyDescriptor方法读取某一个属性的特性值<br>Object.getOwnPropertyDescriptor(test,’age’);</p><h3 id="例子：封装一个拖拽对象"><a href="#例子：封装一个拖拽对象" class="headerlink" title="例子：封装一个拖拽对象"></a>例子：封装一个拖拽对象</h3><p>三种方式：<br>不封装对象直接实现<br>利用原生JavaScript来实现封装拖拽对象<br>通过扩展jQuery来实现拖拽对象</p><blockquote><p>由于修改一个元素top/left值会引起页面重绘，而translate不会，所以优先使用translate属性</p></blockquote><p>如何获取当前浏览器支持的transform兼容写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前浏览器支持的transform兼容写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTransform</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> transform = <span class="string">''</span>,</span><br><span class="line">        divStyle = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>).style,</span><br><span class="line">        <span class="comment">// 可能涉及到的几种兼容性写法，通过循环找出浏览器识别的那一个</span></span><br><span class="line">        transformArr = [<span class="string">'transform'</span>, <span class="string">'webkitTransform'</span>, <span class="string">'MozTransform'</span>, <span class="string">'msTransform'</span>, <span class="string">'OTransform'</span>],</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        len = transformArr.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; i &lt; len; i++)  &#123;</span><br><span class="line">        <span class="keyword">if</span>(transformArr[i] <span class="keyword">in</span> divStyle) &#123;</span><br><span class="line">            <span class="comment">// 找到之后立即返回，结束函数</span></span><br><span class="line">            <span class="keyword">return</span> transform = transformArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到，就直接返回空字符串</span></span><br><span class="line">    <span class="keyword">return</span> transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如何获取当前函数的初始位置<br>需要一个专门用来获取元素样式的功能函数<br>但是获取元素样式在IE浏览器与其他浏览器有一些不同，因此我们需要一个兼容性的写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">elem,property</span>)</span>&#123;</span><br><span class="line"><span class="comment">//ie通过currentStyle来获取元素的样式，其他浏览器通过getComputedStyle来获取</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">document</span>.defaultView.getComputedStyle?<span class="built_in">document</span>.defaultView.getComputedStyle(elem,<span class="literal">false</span>)[property]:elem.currentStyle[property]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>defaultView会返回当前关联的window对象。<br>window.getComputedStyle()方法给出应用活动样式表后的元素的所有的CSS属性的值，并解析这些值可能包含的任何基本计算<br>window.getComputedStyle()语法<br>let style=window.getComputedStyle(elements,[pseudoElt]);<br>element用于获取计算样式Element<br>Element(元素)接口是Document的一个对象。这个接口描述了所有相同种类的元素所普遍具有的方法和属性。<br>psedoElt(可选)<br>指定一个要匹配的伪元素的字符串，必须对普通元素省略(或null)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript有三部分组成&lt;br&gt;核心ECMAscript&lt;br&gt;文档对象模型DOM (Document Object Model) 提供访问和操作网页内容的方法和借口&lt;br&gt;浏览器对象模型BOM (Browser Object Model) 提供与浏览器交互的方法与借口&lt;/p&gt;
&lt;p&gt;组成部分：语法、类型、语句、关键字、保留字、操作符、对象&lt;br&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>软件项目开发</title>
    <link href="http://yoursite.com/2018/03/14/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/03/14/软件项目开发/</id>
    <published>2018-03-14T02:04:31.000Z</published>
    <updated>2018-03-14T04:12:19.340Z</updated>
    
    <content type="html"><![CDATA[<p>项目是为了创造一个唯一的目标而创建的一个临时性的东西</p><p>为了完成具体的任务的<br>成本的约束<br>明确的目标<br>独特性<br>项目的不确定性<br>项目之间有相关性<br><a id="more"></a><br>实现项目目标的制约因素<br>工作范围<br>成本<br>进度计划<br>客户满意度</p><p>社保系统<br>目标实现社会保险管理的七大保险功能<br>1年<br>200万<br>资源10人、设备、资料</p><p>软件开发项目管理定义<br>软件开发项目管理：项目管理、软件项目、经验、技巧</p><p>PMP一个软件管理认证，详情可以去看一下，是项目管理资格的重要标准之一</p><p>PMBOK Project Management Body Of Knowledge缩写，指管理知识体系的意思，PM对项目管理的知识、技能<br>十个领域：<br>重要领域<br>项目整合管理    6个基本子过程：指定项目章程、制定项目管理计划、指导与管理项目执行、监控项目工作、试试整体变更控制、结束项目或阶段<br>项目范围管理    规划范围管理、定义活动<br>项目时间管理<br>项目成本管理<br>项目质量管理<br>次要领域<br>项目人力资源管理<br>项目沟通管理<br>项目风险管理<br>项目采购管理<br>干系人管理</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目是为了创造一个唯一的目标而创建的一个临时性的东西&lt;/p&gt;
&lt;p&gt;为了完成具体的任务的&lt;br&gt;成本的约束&lt;br&gt;明确的目标&lt;br&gt;独特性&lt;br&gt;项目的不确定性&lt;br&gt;项目之间有相关性&lt;br&gt;
    
    </summary>
    
    
      <category term="软件开发的笔记" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Markdown学习笔记</title>
    <link href="http://yoursite.com/2018/03/13/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/03/13/Markdown学习笔记/</id>
    <published>2018-03-13T11:31:07.000Z</published>
    <updated>2018-03-26T07:00:34.485Z</updated>
    
    <content type="html"><![CDATA[<p>markdown<br>轻量化语言，能直接使用纯文本格式编写，转换成相对应的XHTML或者HTML<br><a id="more"></a></p><h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><p>正文</p><h3 id="标题用法"><a href="#标题用法" class="headerlink" title="标题用法"></a>标题用法</h3><ol><li><p>第一种<br>前面带#号后面带标题名称，能表示h1-h6，且一级标题下有横线</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure></li><li><p>第二种<br>一个以上的等号= 上一行即为一级标题 同理-上一行即为二级标题</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一级标题</span><br><span class="line">=====</span><br><span class="line">二级标题</span><br><span class="line">-----</span><br></pre></td></tr></table></figure></li><li><p>第三种<br>与第一种类似，前面带等量的#号，后面就带等量的#号，与第一种方法同义</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题 #</span></span><br><span class="line"><span class="section">## 二级标题 ##</span></span><br><span class="line"><span class="section">### 三级标题 ###</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ol><li>有序列表<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">###有序列表</span></span><br><span class="line"><span class="bullet">1. </span></span><br><span class="line"><span class="bullet">2. </span></span><br><span class="line"><span class="bullet">3. </span></span><br><span class="line"><span class="bullet">4. </span></span><br><span class="line"><span class="bullet">5. </span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><p>2.无序列表<br>可以用+,-,* 三种符号来使用<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">无序列表</span><br><span class="line"><span class="bullet">* </span></span><br><span class="line"><span class="bullet">* </span></span><br><span class="line"><span class="bullet">+ </span></span><br><span class="line">+</span><br><span class="line">-</span><br><span class="line">-</span><br></pre></td></tr></table></figure></p><h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><p>引用某某的话语 使用“&gt;” 英文的右尖括号<br>时间就像海绵里的水,只要愿挤,总还是有的</p><blockquote><p>鲁迅</p></blockquote><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>* + - 三个符号都可以表示，3个连续起来就可以表达为分隔线<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">***</span></span><br><span class="line">---</span><br><span class="line">+++</span><br></pre></td></tr></table></figure></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>两种链接方式：行内式、参数式。两种方式链接文字都是使用[方括号]来标记<br>行内式：<a href="HWKevin.github.io">link</a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">link</span>](<span class="link">HWKevin.github.io</span>)</span><br></pre></td></tr></table></figure></p><p>参数式：<a href="HWKevin.github.io">link_1</a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">link_1</span>]: <span class="link">www.baidu.com</span></span><br><span class="line"></span><br><span class="line">这里是: [link_1]</span><br></pre></td></tr></table></figure></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>行内式、参数式<br>行内式<br>线上图片：<br><a href="https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png" target="_blank" rel="noopener">photo</a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线上图片</span><br><span class="line">[<span class="string">photo</span>](<span class="link">https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png</span>)</span><br><span class="line">本地图片</span><br><span class="line">[<span class="string">photo1</span>](<span class="link">\images\1.png</span>)</span><br></pre></td></tr></table></figure></p><p>参数式参考链接</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p><em>字体倾斜</em> <em>字体倾斜</em> <strong>字体加粗</strong> <strong>字体加粗</strong><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*字体倾斜*</span></span><br><span class="line"><span class="emphasis">_字体倾斜_</span></span><br><span class="line"><span class="strong">**字体加粗**</span></span><br><span class="line"><span class="strong">__字体加粗__</span></span><br></pre></td></tr></table></figure></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p><del>删除的就是我</del><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure></p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>实现<br>标签，只需要在插入处输入两个以上的空格或者一个Tab来实现。</p><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p>利用反斜杠\ 实现插入一些在语法中有其他意义的符号</p><p>借鉴：<a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown语法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;markdown&lt;br&gt;轻量化语言，能直接使用纯文本格式编写，转换成相对应的XHTML或者HTML&lt;br&gt;
    
    </summary>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>第二次写博客</title>
    <link href="http://yoursite.com/2018/03/13/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/03/13/第二次写博客/</id>
    <published>2018-03-13T05:44:40.000Z</published>
    <updated>2018-03-13T05:48:38.798Z</updated>
    
    <content type="html"><![CDATA[<p>不忘初心，做好准备<br><a id="more"></a><br>第一次正式弄好博客，对于我来说，确实有点慢了，感觉应该早一点就弄博客了，之前一直没弄，很后悔没早一点弄好博客<br>但总的来说，现在开始弄也不晚，希望自己能一直保持这种态度。努力前行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不忘初心，做好准备&lt;br&gt;
    
    </summary>
    
    
      <category term="生活闲聊" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>CSS3学习笔记</title>
    <link href="http://yoursite.com/2018/03/12/CSS3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/03/12/CSS3学习笔记/</id>
    <published>2018-03-12T14:49:15.000Z</published>
    <updated>2018-03-14T07:59:22.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS属性"><a href="#CSS属性" class="headerlink" title="CSS属性"></a>CSS属性</h1><ul><li>字体</li><li>颜色</li><li>背景</li><li>尺寸</li><li>边框</li><li>盒 </li><li>内容</li><li>内边距</li><li>外边距</li><li>定位</li><li>列表</li><li>文本属性</li><li>transfrom</li><li>transition</li><li>超链接</li></ul><h2 id="各CSS的属性"><a href="#各CSS的属性" class="headerlink" title="各CSS的属性"></a>各CSS的属性</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>font font-weight line-hight font-size font-color font-family</p><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>opacity<br>filter:Alpha(opacity=50)</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>background</p><h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><p>weight<br>height<br>max-weight min-weight<br>max-height min-height</p><h3 id="生成内容"><a href="#生成内容" class="headerlink" title="生成内容"></a>生成内容</h3><p>content</p><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>border border-top border-left border-right border-bottom border-weight border-style border-color<br>box-shadow border-radius border-image </p><h3 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h3><p>padding padding-top padding-bottom padding-left padding-right </p><h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><p>margin marign-top margin-right margin-bottom marigin-left</p><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>position position:absolute position:relative<br>clear bottom left right top display overflow z-index float veritical-align visibility</p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>target</p><h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><p>color 文字颜色<br>direction 规定文本的方向<br>letter-spacing 字符间距<br>line-height 行高<br>text-align 规定文本的水平对齐方式 :left center right<br>text-decoration 添加到文本的装饰效果 none overline underline blink inherit through<br>text-indent 规定文本块首行的缩进 text-indent</p><h3 id="2D-3D转换属性"><a href="#2D-3D转换属性" class="headerlink" title="2D/3D转换属性"></a>2D/3D转换属性</h3><p>transform 向元素应用2D或3D转换<br>可选：skew倾斜 scale缩小放大 rotate旋转 translate</p><h3 id="过渡属性"><a href="#过渡属性" class="headerlink" title="过渡属性"></a>过渡属性</h3><p>transition transition-property transition-duration transition-timing-function transition-delay<br>transition:name 3s linear ;</p><h3 id="不熟练的属性："><a href="#不熟练的属性：" class="headerlink" title="不熟练的属性："></a>不熟练的属性：</h3><p>background-attachment 设置背景图像是否固定或者随着页面的其余部分滚动<br>background-repeat 设置是否如何重复背景图像<br>background-clip 规定背景的绘制区域<br>background-origin 背景的定位区域</p><h3 id="可伸缩框属性-flexible-box"><a href="#可伸缩框属性-flexible-box" class="headerlink" title="可伸缩框属性(flexible box)"></a>可伸缩框属性(flexible box)</h3><p>box-align 对齐框的子元素<br>box-drection 子元素的显示方向<br>box-flex 规定框的子元素是否可以伸缩<br>box-flex-group 将可伸缩元素分配到柔性分组<br>box-lines 规定当超出元素框的空间时，是否换行显示<br>box-ordinal-group 规定框的子元素显示次序<br>box-orient 福鼎框的子元素是否应水平或垂直排雷<br>box-pack 规定水平框中的水平位置或者垂直框中的垂直位置</p><h1 id="Css3边框"><a href="#Css3边框" class="headerlink" title="Css3边框"></a>Css3边框</h1><h2 id="border-radius-设置圆角"><a href="#border-radius-设置圆角" class="headerlink" title="border-radius 设置圆角"></a>border-radius 设置圆角</h2><p><strong>语法：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">border-radius:10px;</span><br><span class="line">-moz-border-radius:10px; /* old Opera */</span><br></pre></td></tr></table></figure></p><h2 id="box-shadow-边框阴影"><a href="#box-shadow-边框阴影" class="headerlink" title="box-shadow 边框阴影"></a>box-shadow 边框阴影</h2><p><strong>语法：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-shadow: h-shadow w-shadow blur spread color inset;</span><br></pre></td></tr></table></figure></p><ul><li>h-shadow 水平阴影的位置</li><li>w-shadow 垂直阴影的位置</li><li>blur 阴影模糊半径</li><li>spread 阴影扩展半径-其值为正时扩大阴影，其值为负值时，缩小阴影</li><li>color 阴影颜色</li><li>inset 投影方式<br>  可利用blur阴影模糊半径和spread阴影扩展半径弄出每边都不同颜色的效果<br>  box-shadow:-10px 0px 10px -10px blue,0px -10px 10px -10px yellow,10px 0px 10px -10px black,0px 10px 10px -10px green;</li></ul><h2 id="border-image-边框图片"><a href="#border-image-边框图片" class="headerlink" title="border-image 边框图片"></a>border-image 边框图片</h2><p>不支持IE！<br><strong>语法</strong><br>border-image:url(1.png);<br>border-image属性</p><ul><li>border-image-source 图片路径</li><li>border-image-slice 边框向内偏移</li><li>border-image-width 边框宽度</li><li>border-image-outside 超出边框的量</li><li>border-image-repeat 图片边框模式选择。平铺(repeated)、铺满(rounded)、拉伸(streched)</li></ul><h1 id="Css3动画"><a href="#Css3动画" class="headerlink" title="Css3动画"></a>Css3动画</h1><h2 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h2><p>@keyframes中必须要有三个值</p><ol><li>animationname 动画名称</li><li>动画的起始到结束的百分比状态，常用from、to表示直接从0%到100%</li><li>css样式</li></ol><p>例子：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> triangle&#123;</span><br><span class="line">0%&#123;</span><br><span class="line"><span class="attribute">transform</span>:<span class="built_in">rotate</span>(0deg)</span><br><span class="line">&#125;</span><br><span class="line">100%&#123;</span><br><span class="line"><span class="attribute">transform</span>:<span class="built_in">rotate</span>(180deg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h2><h3 id="animation所有动画属性"><a href="#animation所有动画属性" class="headerlink" title="animation所有动画属性"></a>animation所有动画属性</h3><ul><li>animation-name动画名称</li><li>animation-duration一次动画过程所需的时间</li><li>animation-timing-function动画的速度曲线</li><li>animation-delay 动画的延迟时间</li><li>animation-iteration-count 动画所播放的次数</li><li>animation-direction 动画的播放顺序</li><li>animation-play-state 动画的状态</li><li>animation-fill-mode 动画结束的状态</li></ul><p>例子：animation:move 5s linear 1s 2 alternate running forwards<br>分别的含义为：名为move的动画 一个动画时间为5m 移动速度曲线为线性的 加载完成延迟1s后动画开始 动画来回循环 动画运动状态为运行中 动画停止状态为保持最后一帧的结束动画不变</p><pre><code>animation-duration 可以使用秒或者毫秒 s/msanimation-timing-function 速度曲线：linear线性、ease慢快慢、ease-in慢快、ease-out快慢、ease-in-out慢快慢、cubic-bezier(n,n,n,n)（赛贝尔曲线）速度曲线animation-delay 可以为负值，即让动画提前播放，正数即为延迟播放animation-iteration-count 动画播放的次数animation-direction 可选值为normal和alternate ,nomral为普通播放，从0%到100%动画播放。alternate则为来回循环animation-play-state 可选值为running和paused。分别为运行和暂停状态animation-fill-mode 为元素规定填充模式 none不改变默认行为，forwards动画完成保持最后一个属性值，backwards动画完成保持开始的属性值，both前后模式都填充</code></pre><p><strong>例子</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> mymove&#123;</span><br><span class="line"><span class="selector-tag">from</span>&#123;</span><br><span class="line"><span class="attribute">background</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">to</span>&#123;</span><br><span class="line"><span class="attribute">background</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@-<span class="keyword">moz</span>-<span class="keyword">keyframes</span> mymove&#123; <span class="comment">/* Firefox */</span></span><br><span class="line"><span class="selector-tag">from</span>&#123;</span><br><span class="line"><span class="attribute">background</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">to</span>&#123;</span><br><span class="line"><span class="attribute">background</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> mymove&#123; <span class="comment">/* Safari Chrome */</span></span><br><span class="line"><span class="selector-tag">from</span>&#123;</span><br><span class="line"><span class="attribute">background</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">to</span>&#123;</span><br><span class="line"><span class="attribute">background</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@-<span class="keyword">o</span>-<span class="keyword">keyframes</span> mymove&#123; <span class="comment">/* Opera */</span></span><br><span class="line"><span class="selector-tag">from</span>&#123;</span><br><span class="line"><span class="attribute">background</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">to</span>&#123;</span><br><span class="line"><span class="attribute">background</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      CSS3笔记
    
    </summary>
    
      <category term="CSS3" scheme="http://yoursite.com/categories/CSS3/"/>
    
    
      <category term="CSS3 学习笔记" scheme="http://yoursite.com/tags/CSS3-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
